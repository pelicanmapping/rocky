

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File rtree.h &mdash; Rocky SDK 0.9.8 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=29de89ba" />
      <link rel="stylesheet" type="text/css" href="../_static/collapsible-lists/css/tree_view.css?v=a885cde7" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=29de89ba" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=1a282f62"></script>
      <script src="../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js?v=73120307"></script>
      <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js?v=660e4f45"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <a href="../index.html" class="icon icon-home">
            Rocky SDK
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting_started.html">Getting Started with Rocky</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/maps_and_layers.html">Maps and Layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/ecs_system.html">Entity Component System</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../examples/hello_world.html">Hello World</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Rocky SDK</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Program Listing for File rtree.h</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/program_listing_file_src_rocky_rtree.h.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-rtree-h">
<span id="program-listing-file-src-rocky-rtree-h"></span><h1>Program Listing for File rtree.h<a class="headerlink" href="#program-listing-for-file-rtree-h" title="Link to this heading"></a></h1>
<p>↰ <a class="reference internal" href="file_src_rocky_rtree.h.html#file-src-rocky-rtree-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/rocky/rtree.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef RTREE_H</span>
<span class="cp">#define RTREE_H</span>

<span class="c1">// NOTE This file compiles under MSVC 6 SP5 and MSVC .Net 2003 it may not work on other compilers without modification.</span>

<span class="c1">// NOTE These next few lines may be win32 specific, you may need to modify them to compile on other platform</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;assert.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;algorithm&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;limits&gt;</span>

<span class="cp">#define ASSERT assert </span><span class="c1">// RTree uses ASSERT( condition )</span>
<span class="cp">#ifndef Min</span>
<span class="cp">#define Min std::min</span>
<span class="cp">#endif </span><span class="c1">//Min</span>
<span class="cp">#ifndef Max</span>
<span class="cp">#define Max std::max</span>
<span class="cp">#endif </span><span class="c1">//Max</span>

<span class="c1">//</span>
<span class="c1">// RTree.h</span>
<span class="c1">//</span>

<span class="cp">#define RTREE_TEMPLATE template&lt;class DATATYPE, class ELEMTYPE, int NUMDIMS, class ELEMTYPEREAL, int TMAXNODES, int TMINNODES&gt;</span>
<span class="cp">#define RTREE_QUAL RTree&lt;DATATYPE, ELEMTYPE, NUMDIMS, ELEMTYPEREAL, TMAXNODES, TMINNODES&gt;</span>

<span class="cp">#define RTREE_DONT_USE_MEMPOOLS </span><span class="c1">// This version does not contain a fixed memory allocator, fill in lines with EXAMPLE to implement one.</span>
<span class="c1">// #define RTREE_USE_SPHERICAL_VOLUME // Better split classification, may be slower on some systems</span>
<span class="cp">#define RTREE_USE_LINEAR_SPLIT </span><span class="c1">// Faster O(n) split seed selection instead of O(n²)</span>

<span class="c1">// gw</span>
<span class="cp">#define RTREE_STOP_SEARCHING false</span>
<span class="cp">#define RTREE_KEEP_SEARCHING true</span>

<span class="c1">// Fwd decl</span>
<span class="k">class</span><span class="w"> </span><span class="nc">RTFileStream</span><span class="p">;</span><span class="w">  </span><span class="c1">// File I/O helper class, look below for implementation and notes.</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">DATATYPE</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ELEMTYPE</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">,</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">ELEMTYPEREAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">TMAXNODES</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">TMINNODES</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TMAXNODES</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">RTree</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">ELEMTYPEREAL</span><span class="o">&gt;::</span><span class="n">is_iec559</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&#39;ELEMTYPEREAL&#39; accepts floating-point types only&quot;</span><span class="p">);</span>

<span class="k">protected</span><span class="o">:</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="p">;</span><span class="w">  </span><span class="c1">// Fwd decl.  Used by other internal structs and iterator</span>

<span class="k">public</span><span class="o">:</span>

<span class="w">    </span><span class="c1">// These constant must be declared after Branch and before Node struct</span>
<span class="w">    </span><span class="c1">// Stuck up here for MSVC 6 compiler.  NSVC .NET 2003 is much happier.</span>
<span class="w">    </span><span class="k">enum</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">MAXNODES</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TMAXNODES</span><span class="p">,</span>
<span class="w">        </span><span class="n">MINNODES</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TMINNODES</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>

<span class="k">public</span><span class="o">:</span>

<span class="w">    </span><span class="n">RTree</span><span class="p">();</span>
<span class="w">    </span><span class="n">RTree</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">RTree</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">RTree</span><span class="p">();</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Insert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_min</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_dataId</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Remove</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_min</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_dataId</span><span class="p">);</span>

<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">DefaultCallbackType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">CALLBACK_TYPE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DefaultCallbackType</span><span class="o">&gt;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Search</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_min</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span>
<span class="w">        </span><span class="n">CALLBACK_TYPE</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Intersects</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_min</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">])</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">RemoveAll</span><span class="p">();</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">Count</span><span class="p">();</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Load</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">a_fileName</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Load</span><span class="p">(</span><span class="n">RTFileStream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_stream</span><span class="p">);</span>


<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Save</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">a_fileName</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Save</span><span class="p">(</span><span class="n">RTFileStream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_stream</span><span class="p">);</span>

<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">Iterator</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>

<span class="w">        </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MAX_STACK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">//  Max stack size. Allows almost n^32 where n is number of branches in node</span>

<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">StackElement</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">m_node</span><span class="p">;</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">m_branchIndex</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>

<span class="w">        </span><span class="n">Iterator</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Init</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>

<span class="w">        </span><span class="o">~</span><span class="n">Iterator</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsNull</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">m_tos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsNotNull</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">m_tos</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>

<span class="w">        </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">IsNotNull</span><span class="p">());</span>
<span class="w">            </span><span class="n">StackElement</span><span class="o">&amp;</span><span class="w"> </span><span class="n">curTos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_stack</span><span class="p">[</span><span class="n">m_tos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">curTos</span><span class="p">.</span><span class="n">m_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">curTos</span><span class="p">.</span><span class="n">m_branchIndex</span><span class="p">].</span><span class="n">m_data</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">IsNotNull</span><span class="p">());</span>
<span class="w">            </span><span class="n">StackElement</span><span class="o">&amp;</span><span class="w"> </span><span class="n">curTos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_stack</span><span class="p">[</span><span class="n">m_tos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">curTos</span><span class="p">.</span><span class="n">m_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">curTos</span><span class="p">.</span><span class="n">m_branchIndex</span><span class="p">].</span><span class="n">m_data</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">++</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">FindNextData</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">GetBounds</span><span class="p">(</span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_min</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">])</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">IsNotNull</span><span class="p">());</span>
<span class="w">            </span><span class="n">StackElement</span><span class="o">&amp;</span><span class="w"> </span><span class="n">curTos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_stack</span><span class="p">[</span><span class="n">m_tos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">            </span><span class="n">Branch</span><span class="o">&amp;</span><span class="w"> </span><span class="n">curBranch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curTos</span><span class="p">.</span><span class="n">m_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">curTos</span><span class="p">.</span><span class="n">m_branchIndex</span><span class="p">];</span>

<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">a_min</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curBranch</span><span class="p">.</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">                </span><span class="n">a_max</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curBranch</span><span class="p">.</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">    </span><span class="k">private</span><span class="o">:</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">Init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">m_tos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">FindNextData</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_tos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="n">StackElement</span><span class="w"> </span><span class="n">curTos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pop</span><span class="p">();</span><span class="w"> </span><span class="c1">// Copy stack top cause it may change as we use it</span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curTos</span><span class="p">.</span><span class="n">m_node</span><span class="o">-&gt;</span><span class="n">IsLeaf</span><span class="p">())</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="c1">// Keep walking through data while we can</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curTos</span><span class="p">.</span><span class="n">m_branchIndex</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">curTos</span><span class="p">.</span><span class="n">m_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="c1">// There is more data, just point to the next one</span>
<span class="w">                        </span><span class="n">Push</span><span class="p">(</span><span class="n">curTos</span><span class="p">.</span><span class="n">m_node</span><span class="p">,</span><span class="w"> </span><span class="n">curTos</span><span class="p">.</span><span class="n">m_branchIndex</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="c1">// No more data, so it will fall back to previous level</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curTos</span><span class="p">.</span><span class="n">m_branchIndex</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">curTos</span><span class="p">.</span><span class="n">m_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="c1">// Push sibling on for future tree walk</span>
<span class="w">                        </span><span class="c1">// This is the &#39;fall back&#39; node when we finish with the current level</span>
<span class="w">                        </span><span class="n">Push</span><span class="p">(</span><span class="n">curTos</span><span class="p">.</span><span class="n">m_node</span><span class="p">,</span><span class="w"> </span><span class="n">curTos</span><span class="p">.</span><span class="n">m_branchIndex</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="c1">// Since cur node is not a leaf, push first of next level to get deeper into the tree</span>
<span class="w">                    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">nextLevelnode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curTos</span><span class="p">.</span><span class="n">m_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">curTos</span><span class="p">.</span><span class="n">m_branchIndex</span><span class="p">].</span><span class="n">m_child</span><span class="p">;</span>
<span class="w">                    </span><span class="n">Push</span><span class="p">(</span><span class="n">nextLevelnode</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">                    </span><span class="c1">// If we pushed on a new leaf, exit as the data is ready at TOS</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nextLevelnode</span><span class="o">-&gt;</span><span class="n">IsLeaf</span><span class="p">())</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">Push</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_branchIndex</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_stack</span><span class="p">[</span><span class="n">m_tos</span><span class="p">].</span><span class="n">m_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_node</span><span class="p">;</span>
<span class="w">            </span><span class="n">m_stack</span><span class="p">[</span><span class="n">m_tos</span><span class="p">].</span><span class="n">m_branchIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_branchIndex</span><span class="p">;</span>
<span class="w">            </span><span class="o">++</span><span class="n">m_tos</span><span class="p">;</span>
<span class="w">            </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">m_tos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">MAX_STACK</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">StackElement</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Pop</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">m_tos</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">            </span><span class="o">--</span><span class="n">m_tos</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">m_stack</span><span class="p">[</span><span class="n">m_tos</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">StackElement</span><span class="w"> </span><span class="n">m_stack</span><span class="p">[</span><span class="n">MAX_STACK</span><span class="p">];</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">m_tos</span><span class="p">;</span>

<span class="w">        </span><span class="k">friend</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">RTree</span><span class="p">;</span><span class="w"> </span><span class="c1">// Allow hiding of non-public functions while allowing manipulation by logical owner</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">GetFirst</span><span class="p">(</span><span class="n">Iterator</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_it</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">a_it</span><span class="p">.</span><span class="n">Init</span><span class="p">();</span>
<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_root</span><span class="p">;</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">IsInternalNode</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">first</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">a_it</span><span class="p">.</span><span class="n">Push</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Descend sibling branch later</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">IsLeaf</span><span class="p">())</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">a_it</span><span class="p">.</span><span class="n">Push</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m_child</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">GetNext</span><span class="p">(</span><span class="n">Iterator</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">++</span><span class="n">a_it</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">IsNull</span><span class="p">(</span><span class="n">Iterator</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a_it</span><span class="p">.</span><span class="n">IsNull</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">GetAt</span><span class="p">(</span><span class="n">Iterator</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">a_it</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Rect</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">m_min</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">];</span>
<span class="w">        </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">m_max</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">];</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Branch</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Rect</span><span class="w"> </span><span class="n">m_rect</span><span class="p">;</span>
<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">m_child</span><span class="p">;</span>
<span class="w">        </span><span class="n">DATATYPE</span><span class="w"> </span><span class="n">m_data</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">IsInternalNode</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">m_level</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// Not a leaf, but a internal node</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">IsLeaf</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">m_level</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// A leaf, contains data</span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">m_count</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">m_level</span><span class="p">;</span>
<span class="w">        </span><span class="n">Branch</span><span class="w"> </span><span class="n">m_branch</span><span class="p">[</span><span class="n">MAXNODES</span><span class="p">];</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">m_next</span><span class="p">;</span>
<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">m_node</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">PartitionVars</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">NOT_TAKEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// indicates that position</span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">m_partition</span><span class="p">[</span><span class="n">MAXNODES</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">m_total</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">m_minFill</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">m_count</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">        </span><span class="n">Rect</span><span class="w"> </span><span class="n">m_cover</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">        </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">m_area</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="w">        </span><span class="n">Branch</span><span class="w"> </span><span class="n">m_branchBuf</span><span class="p">[</span><span class="n">MAXNODES</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">m_branchCount</span><span class="p">;</span>
<span class="w">        </span><span class="n">Rect</span><span class="w"> </span><span class="n">m_coverSplit</span><span class="p">;</span>
<span class="w">        </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">m_coverSplitArea</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="nf">AllocNode</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">FreeNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">InitNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">InitRect</span><span class="p">(</span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">InsertRectRec</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Branch</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">**</span><span class="w"> </span><span class="n">a_newNode</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_level</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">InsertRect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Branch</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">**</span><span class="w"> </span><span class="n">a_root</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_level</span><span class="p">);</span>
<span class="w">    </span><span class="n">Rect</span><span class="w"> </span><span class="nf">NodeCover</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">AddBranch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Branch</span><span class="o">*</span><span class="w"> </span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">**</span><span class="w"> </span><span class="n">a_newNode</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">DisconnectBranch</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_index</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">PickBranch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">);</span>
<span class="w">    </span><span class="n">Rect</span><span class="w"> </span><span class="nf">CombineRect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rectA</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rectB</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">CombineRect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rectA</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rectB</span><span class="p">,</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_result</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">SplitNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Branch</span><span class="o">*</span><span class="w"> </span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">**</span><span class="w"> </span><span class="n">a_newNode</span><span class="p">);</span>
<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="nf">RectSphericalVolume</span><span class="p">(</span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">);</span>
<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="nf">RectVolume</span><span class="p">(</span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">);</span>
<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="nf">CalcRectVolume</span><span class="p">(</span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">GetBranches</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Branch</span><span class="o">*</span><span class="w"> </span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">ChoosePartition</span><span class="p">(</span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_minFill</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">LoadNodes</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_nodeA</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_nodeB</span><span class="p">,</span><span class="w"> </span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">InitParVars</span><span class="p">(</span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_maxRects</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_minFill</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">PickSeeds</span><span class="p">(</span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">PickSeedsLinear</span><span class="p">(</span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Classify</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a_index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_group</span><span class="p">,</span><span class="w"> </span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">RemoveRect</span><span class="p">(</span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">**</span><span class="w"> </span><span class="n">a_root</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">RemoveRectRec</span><span class="p">(</span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">a_listNode</span><span class="p">);</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="nf">AllocListNode</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">FreeListNode</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">a_listNode</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Overlap</span><span class="p">(</span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rectA</span><span class="p">,</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rectB</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">ReInsert</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">a_listNode</span><span class="p">);</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">CALLBACK_TYPE</span><span class="o">&gt;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">Search</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_foundCount</span><span class="p">,</span><span class="w"> </span><span class="n">CALLBACK_TYPE</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">RemoveAllRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Reset</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">CountRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_count</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">SaveRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">RTFileStream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_stream</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">LoadRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">RTFileStream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_stream</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">CopyRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">m_root</span><span class="p">;</span>
<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">m_unitSphereVolume</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">m_freeNodes</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">m_freeListNodes</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// return all the AABBs that form the RTree</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Rect</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ListTree</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">// Because there is not stream support, this is a quick and dirty file I/O helper.</span>
<span class="c1">// Users will likely replace its usage with a Stream implementation from their favorite API.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">RTFileStream</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">m_file</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>


<span class="w">    </span><span class="n">RTFileStream</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">m_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">~</span><span class="n">RTFileStream</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Close</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">Open</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">a_fileName</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">mode</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="cp">#if defined(_WIN32) &amp;&amp; defined(__STDC_WANT_SECURE_LIB__)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fopen_s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_file</span><span class="p">,</span><span class="w"> </span><span class="n">a_fileName</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="w">        </span><span class="n">m_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">a_fileName</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">m_file</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">OpenRead</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">a_fileName</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Open</span><span class="p">(</span><span class="n">a_fileName</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;rb&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">OpenWrite</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">a_fileName</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Open</span><span class="p">(</span><span class="n">a_fileName</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;wb&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Close</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_file</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">fclose</span><span class="p">(</span><span class="n">m_file</span><span class="p">);</span>
<span class="w">            </span><span class="n">m_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TYPE</span><span class="w"> </span><span class="o">&gt;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Write</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TYPE</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_value</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">m_file</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fwrite</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">a_value</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">a_value</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">m_file</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TYPE</span><span class="w"> </span><span class="o">&gt;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">WriteArray</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TYPE</span><span class="o">*</span><span class="w"> </span><span class="n">a_array</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_count</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">m_file</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fwrite</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">a_array</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">TYPE</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a_count</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">m_file</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TYPE</span><span class="w"> </span><span class="o">&gt;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Read</span><span class="p">(</span><span class="n">TYPE</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_value</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">m_file</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fread</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">a_value</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">a_value</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">m_file</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TYPE</span><span class="w"> </span><span class="o">&gt;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">ReadArray</span><span class="p">(</span><span class="n">TYPE</span><span class="o">*</span><span class="w"> </span><span class="n">a_array</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_count</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">m_file</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fread</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">a_array</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">TYPE</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a_count</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">m_file</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="nf">RTREE_QUAL::RTree</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">MAXNODES</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">MINNODES</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">MINNODES</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Precomputed volumes of the unit spheres for the first few dimensions</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">UNIT_SPHERE_VOLUMES</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="mf">0.000000f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.000000f</span><span class="p">,</span><span class="w"> </span><span class="mf">3.141593f</span><span class="p">,</span><span class="w"> </span><span class="c1">// Dimension  0,1,2</span>
<span class="w">      </span><span class="mf">4.188790f</span><span class="p">,</span><span class="w"> </span><span class="mf">4.934802f</span><span class="p">,</span><span class="w"> </span><span class="mf">5.263789f</span><span class="p">,</span><span class="w"> </span><span class="c1">// Dimension  3,4,5</span>
<span class="w">      </span><span class="mf">5.167713f</span><span class="p">,</span><span class="w"> </span><span class="mf">4.724766f</span><span class="p">,</span><span class="w"> </span><span class="mf">4.058712f</span><span class="p">,</span><span class="w"> </span><span class="c1">// Dimension  6,7,8</span>
<span class="w">      </span><span class="mf">3.298509f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.550164f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.884104f</span><span class="p">,</span><span class="w"> </span><span class="c1">// Dimension  9,10,11</span>
<span class="w">      </span><span class="mf">1.335263f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.910629f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.599265f</span><span class="p">,</span><span class="w"> </span><span class="c1">// Dimension  12,13,14</span>
<span class="w">      </span><span class="mf">0.381443f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.235331f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.140981f</span><span class="p">,</span><span class="w"> </span><span class="c1">// Dimension  15,16,17</span>
<span class="w">      </span><span class="mf">0.082146f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.046622f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.025807f</span><span class="p">,</span><span class="w"> </span><span class="c1">// Dimension  18,19,20</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">m_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AllocNode</span><span class="p">();</span>
<span class="w">    </span><span class="n">m_root</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">m_unitSphereVolume</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">)</span><span class="n">UNIT_SPHERE_VOLUMES</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">];</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="nf">RTREE_QUAL::RTree</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">RTree</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">RTree</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">CopyRec</span><span class="p">(</span><span class="n">m_root</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">m_root</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="n">RTREE_QUAL</span><span class="o">::~</span><span class="n">RTree</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Reset</span><span class="p">();</span><span class="w"> </span><span class="c1">// Free, or reset node memory</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">Insert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_min</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_dataId</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef _DEBUG</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_min</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="cp">#endif </span><span class="c1">//_DEBUG</span>

<span class="w">    </span><span class="n">Branch</span><span class="w"> </span><span class="n">branch</span><span class="p">;</span>
<span class="w">    </span><span class="n">branch</span><span class="p">.</span><span class="n">m_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_dataId</span><span class="p">;</span>
<span class="w">    </span><span class="n">branch</span><span class="p">.</span><span class="n">m_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">axis</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">branch</span><span class="p">.</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_min</span><span class="p">[</span><span class="n">axis</span><span class="p">];</span>
<span class="w">        </span><span class="n">branch</span><span class="p">.</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">axis</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">InsertRect</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_root</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">Remove</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_min</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_dataId</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef _DEBUG</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_min</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="cp">#endif </span><span class="c1">//_DEBUG</span>

<span class="w">    </span><span class="n">Rect</span><span class="w"> </span><span class="n">rect</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">axis</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_min</span><span class="p">[</span><span class="n">axis</span><span class="p">];</span>
<span class="w">        </span><span class="n">rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">axis</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">RemoveRect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rect</span><span class="p">,</span><span class="w"> </span><span class="n">a_dataId</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_root</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">CALLBACK_TYPE</span><span class="o">&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">Search</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_min</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span><span class="w"> </span><span class="n">CALLBACK_TYPE</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="cp">#ifdef _DEBUG</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_min</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="cp">#endif </span><span class="c1">//_DEBUG</span>

<span class="w">    </span><span class="n">Rect</span><span class="w"> </span><span class="n">rect</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">axis</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_min</span><span class="p">[</span><span class="n">axis</span><span class="p">];</span>
<span class="w">        </span><span class="n">rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">axis</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// NOTE: May want to return search result another way, perhaps returning the number of found elements here.</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">foundCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">Search</span><span class="p">(</span><span class="n">m_root</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rect</span><span class="p">,</span><span class="w"> </span><span class="n">foundCount</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">foundCount</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">RTREE_TEMPLATE</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">Intersects</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_min</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">a_max</span><span class="p">[</span><span class="n">NUMDIMS</span><span class="p">])</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Search</span><span class="p">(</span><span class="n">a_min</span><span class="p">,</span><span class="w"> </span><span class="n">a_max</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">RTREE_TEMPLATE</span>
<span class="kt">int</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">Count</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">CountRec</span><span class="p">(</span><span class="n">m_root</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>



<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">CountRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_count</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">IsInternalNode</span><span class="p">())</span><span class="w">  </span><span class="c1">// not a leaf node</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">CountRec</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_child</span><span class="p">,</span><span class="w"> </span><span class="n">a_count</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="c1">// A leaf node</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">a_count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">Load</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">a_fileName</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">RemoveAll</span><span class="p">();</span><span class="w"> </span><span class="c1">// Clear existing tree</span>

<span class="w">    </span><span class="n">RTFileStream</span><span class="w"> </span><span class="n">stream</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">stream</span><span class="p">.</span><span class="n">OpenRead</span><span class="p">(</span><span class="n">a_fileName</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Load</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>

<span class="w">    </span><span class="n">stream</span><span class="p">.</span><span class="n">Close</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>



<span class="n">RTREE_TEMPLATE</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">Load</span><span class="p">(</span><span class="n">RTFileStream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_stream</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Write some kind of header</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">_dataFileId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;R&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;T&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;R&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;E&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">_dataSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">DATATYPE</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">_dataNumDims</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">_dataElemSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ELEMTYPE</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">_dataElemRealSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">_dataMaxNodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TMAXNODES</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">_dataMinNodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TMINNODES</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataFileId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataNumDims</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataElemSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataElemRealSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataMaxNodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataMinNodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="n">dataFileId</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="n">dataSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="n">dataNumDims</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="n">dataElemSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="n">dataElemRealSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="n">dataMaxNodes</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="n">dataMinNodes</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Test if header was valid and compatible</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">dataFileId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">_dataFileId</span><span class="p">)</span>
<span class="w">        </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">dataSize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">_dataSize</span><span class="p">)</span>
<span class="w">        </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">dataNumDims</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">_dataNumDims</span><span class="p">)</span>
<span class="w">        </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">dataElemSize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">_dataElemSize</span><span class="p">)</span>
<span class="w">        </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">dataElemRealSize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">_dataElemRealSize</span><span class="p">)</span>
<span class="w">        </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">dataMaxNodes</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">_dataMaxNodes</span><span class="p">)</span>
<span class="w">        </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">dataMinNodes</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">_dataMinNodes</span><span class="p">)</span>
<span class="w">        </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Recursively load tree</span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LoadRec</span><span class="p">(</span><span class="n">m_root</span><span class="p">,</span><span class="w"> </span><span class="n">a_stream</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">LoadRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">RTFileStream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_stream</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">IsInternalNode</span><span class="p">())</span><span class="w">  </span><span class="c1">// not a leaf node</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Branch</span><span class="o">*</span><span class="w"> </span><span class="n">curBranch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

<span class="w">            </span><span class="n">a_stream</span><span class="p">.</span><span class="n">ReadArray</span><span class="p">(</span><span class="n">curBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">,</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">);</span>
<span class="w">            </span><span class="n">a_stream</span><span class="p">.</span><span class="n">ReadArray</span><span class="p">(</span><span class="n">curBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">,</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">);</span>

<span class="w">            </span><span class="n">curBranch</span><span class="o">-&gt;</span><span class="n">m_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AllocNode</span><span class="p">();</span>
<span class="w">            </span><span class="n">LoadRec</span><span class="p">(</span><span class="n">curBranch</span><span class="o">-&gt;</span><span class="n">m_child</span><span class="p">,</span><span class="w"> </span><span class="n">a_stream</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="c1">// A leaf node</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Branch</span><span class="o">*</span><span class="w"> </span><span class="n">curBranch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

<span class="w">            </span><span class="n">a_stream</span><span class="p">.</span><span class="n">ReadArray</span><span class="p">(</span><span class="n">curBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">,</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">);</span>
<span class="w">            </span><span class="n">a_stream</span><span class="p">.</span><span class="n">ReadArray</span><span class="p">(</span><span class="n">curBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">,</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">);</span>

<span class="w">            </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="n">curBranch</span><span class="o">-&gt;</span><span class="n">m_data</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Should do more error checking on I/O operations</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">CopyRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="p">;</span>
<span class="w">    </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">IsInternalNode</span><span class="p">())</span><span class="w">  </span><span class="c1">// not a leaf node</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Branch</span><span class="o">*</span><span class="w"> </span><span class="n">currentBranch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">            </span><span class="n">Branch</span><span class="o">*</span><span class="w"> </span><span class="n">otherBranch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">otherBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">,</span>
<span class="w">                </span><span class="n">otherBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">,</span>
<span class="w">                </span><span class="n">currentBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">);</span>

<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">otherBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">,</span>
<span class="w">                </span><span class="n">otherBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">,</span>
<span class="w">                </span><span class="n">currentBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">);</span>

<span class="w">            </span><span class="n">currentBranch</span><span class="o">-&gt;</span><span class="n">m_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AllocNode</span><span class="p">();</span>
<span class="w">            </span><span class="n">CopyRec</span><span class="p">(</span><span class="n">currentBranch</span><span class="o">-&gt;</span><span class="n">m_child</span><span class="p">,</span><span class="w"> </span><span class="n">otherBranch</span><span class="o">-&gt;</span><span class="n">m_child</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="c1">// A leaf node</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Branch</span><span class="o">*</span><span class="w"> </span><span class="n">currentBranch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">            </span><span class="n">Branch</span><span class="o">*</span><span class="w"> </span><span class="n">otherBranch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">otherBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">,</span>
<span class="w">                </span><span class="n">otherBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">,</span>
<span class="w">                </span><span class="n">currentBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">);</span>

<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">otherBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">,</span>
<span class="w">                </span><span class="n">otherBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">,</span>
<span class="w">                </span><span class="n">currentBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">);</span>

<span class="w">            </span><span class="n">currentBranch</span><span class="o">-&gt;</span><span class="n">m_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">otherBranch</span><span class="o">-&gt;</span><span class="n">m_data</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">Save</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">a_fileName</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">RTFileStream</span><span class="w"> </span><span class="n">stream</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">stream</span><span class="p">.</span><span class="n">OpenWrite</span><span class="p">(</span><span class="n">a_fileName</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Save</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>

<span class="w">    </span><span class="n">stream</span><span class="p">.</span><span class="n">Close</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">Save</span><span class="p">(</span><span class="n">RTFileStream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_stream</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Write some kind of header</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataFileId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;R&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;T&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;R&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;E&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">DATATYPE</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataNumDims</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataElemSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ELEMTYPE</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataElemRealSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataMaxNodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TMAXNODES</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataMinNodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TMINNODES</span><span class="p">;</span>

<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">dataFileId</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">dataSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">dataNumDims</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">dataElemSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">dataElemRealSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">dataMaxNodes</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">dataMinNodes</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Recursively save tree</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SaveRec</span><span class="p">(</span><span class="n">m_root</span><span class="p">,</span><span class="w"> </span><span class="n">a_stream</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">SaveRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">RTFileStream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_stream</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">IsInternalNode</span><span class="p">())</span><span class="w">  </span><span class="c1">// not a leaf node</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Branch</span><span class="o">*</span><span class="w"> </span><span class="n">curBranch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

<span class="w">            </span><span class="n">a_stream</span><span class="p">.</span><span class="n">WriteArray</span><span class="p">(</span><span class="n">curBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">,</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">);</span>
<span class="w">            </span><span class="n">a_stream</span><span class="p">.</span><span class="n">WriteArray</span><span class="p">(</span><span class="n">curBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">,</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">);</span>

<span class="w">            </span><span class="n">SaveRec</span><span class="p">(</span><span class="n">curBranch</span><span class="o">-&gt;</span><span class="n">m_child</span><span class="p">,</span><span class="w"> </span><span class="n">a_stream</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="c1">// A leaf node</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Branch</span><span class="o">*</span><span class="w"> </span><span class="n">curBranch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

<span class="w">            </span><span class="n">a_stream</span><span class="p">.</span><span class="n">WriteArray</span><span class="p">(</span><span class="n">curBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">,</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">);</span>
<span class="w">            </span><span class="n">a_stream</span><span class="p">.</span><span class="n">WriteArray</span><span class="p">(</span><span class="n">curBranch</span><span class="o">-&gt;</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">,</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">);</span>

<span class="w">            </span><span class="n">a_stream</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">curBranch</span><span class="o">-&gt;</span><span class="n">m_data</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Should do more error checking on I/O operations</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">RemoveAll</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Delete all existing nodes</span>
<span class="w">    </span><span class="n">Reset</span><span class="p">();</span>

<span class="w">    </span><span class="n">m_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AllocNode</span><span class="p">();</span>
<span class="w">    </span><span class="n">m_root</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">Reset</span><span class="p">()</span>
<span class="p">{</span>
<span class="cp">#ifdef RTREE_DONT_USE_MEMPOOLS</span>
<span class="w">    </span><span class="c1">// Delete all existing nodes</span>
<span class="w">    </span><span class="n">RemoveAllRec</span><span class="p">(</span><span class="n">m_root</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Clean up node pool</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_freeNodes</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">delete</span><span class="w"> </span><span class="n">node</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">m_freeNodes</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// Clean up list node pool</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_freeListNodes</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">delete</span><span class="w"> </span><span class="n">node</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">m_freeListNodes</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="cp">#else </span><span class="c1">// RTREE_DONT_USE_MEMPOOLS</span>
<span class="w">    </span><span class="c1">// Just reset memory pools.  We are not using complex types</span>
<span class="w">    </span><span class="c1">// EXAMPLE</span>
<span class="cp">#endif </span><span class="c1">// RTREE_DONT_USE_MEMPOOLS</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">RemoveAllRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_node</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">IsInternalNode</span><span class="p">())</span><span class="w"> </span><span class="c1">// This is an internal node in the tree</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">RemoveAllRec</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_child</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">FreeNode</span><span class="p">(</span><span class="n">a_node</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="k">typename</span><span class="w"> </span><span class="nc">RTREE_QUAL</span><span class="o">::</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">AllocNode</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">newNode</span><span class="p">;</span>
<span class="cp">#ifdef RTREE_DONT_USE_MEMPOOLS</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">m_freeNodes</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">newNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_freeNodes</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
<span class="w">        </span><span class="n">m_freeNodes</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">newNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="cp">#else </span><span class="c1">// RTREE_DONT_USE_MEMPOOLS</span>
<span class="w">    </span><span class="c1">// EXAMPLE</span>
<span class="cp">#endif </span><span class="c1">// RTREE_DONT_USE_MEMPOOLS</span>
<span class="w">    </span><span class="n">InitNode</span><span class="p">(</span><span class="n">newNode</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">newNode</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">FreeNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_node</span><span class="p">);</span>

<span class="cp">#ifdef RTREE_DONT_USE_MEMPOOLS</span>
<span class="w">    </span><span class="n">m_freeNodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a_node</span><span class="p">);</span>
<span class="cp">#else </span><span class="c1">// RTREE_DONT_USE_MEMPOOLS</span>
<span class="w">    </span><span class="c1">// EXAMPLE</span>
<span class="cp">#endif </span><span class="c1">// RTREE_DONT_USE_MEMPOOLS</span>
<span class="p">}</span>


<span class="c1">// Allocate space for a node in the list used in DeletRect to</span>
<span class="c1">// store Nodes that are too empty.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="k">typename</span><span class="w"> </span><span class="nc">RTREE_QUAL</span><span class="o">::</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">AllocListNode</span><span class="p">()</span>
<span class="p">{</span>
<span class="cp">#ifdef RTREE_DONT_USE_MEMPOOLS</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">m_freeListNodes</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_freeListNodes</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
<span class="w">        </span><span class="n">m_freeListNodes</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">node</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="p">;</span>
<span class="cp">#else </span><span class="c1">// RTREE_DONT_USE_MEMPOOLS</span>
<span class="w">    </span><span class="c1">// EXAMPLE</span>
<span class="cp">#endif </span><span class="c1">// RTREE_DONT_USE_MEMPOOLS</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">FreeListNode</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">a_listNode</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef RTREE_DONT_USE_MEMPOOLS</span>
<span class="w">    </span><span class="n">m_freeListNodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a_listNode</span><span class="p">);</span>
<span class="cp">#else </span><span class="c1">// RTREE_DONT_USE_MEMPOOLS</span>
<span class="w">    </span><span class="c1">// EXAMPLE</span>
<span class="cp">#endif </span><span class="c1">// RTREE_DONT_USE_MEMPOOLS</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">InitNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">InitRect</span><span class="p">(</span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">a_rect</span><span class="o">-&gt;</span><span class="n">m_min</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPE</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">a_rect</span><span class="o">-&gt;</span><span class="n">m_max</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPE</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Inserts a new data rectangle into the index structure.</span>
<span class="c1">// Recursively descends tree, propagates splits back up.</span>
<span class="c1">// Returns 0 if node was not split.  Old node updated.</span>
<span class="c1">// If node was split, returns 1 and sets the pointer pointed to by</span>
<span class="c1">// new_node to point to the new node.  Old node updated to become one of two.</span>
<span class="c1">// The level argument specifies the number of steps up from the leaf</span>
<span class="c1">// level to insert; e.g. a data rectangle goes in at level = 0.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">InsertRectRec</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Branch</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">**</span><span class="w"> </span><span class="n">a_newNode</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_level</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_node</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a_newNode</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_level</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a_level</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// recurse until we reach the correct level for the new record. data records</span>
<span class="w">    </span><span class="c1">// will always be called with a_level == 0 (leaf)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">a_level</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Still above level for insertion, go down tree recursively</span>
<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">otherNode</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// find the optimal branch for this record</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PickBranch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a_branch</span><span class="p">.</span><span class="n">m_rect</span><span class="p">,</span><span class="w"> </span><span class="n">a_node</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// recursively insert this record into the picked branch</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">childWasSplit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InsertRectRec</span><span class="p">(</span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_child</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">otherNode</span><span class="p">,</span><span class="w"> </span><span class="n">a_level</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">childWasSplit</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Child was not split. Merge the bounding box of the new record with the</span>
<span class="w">            </span><span class="c1">// existing bounding box</span>
<span class="w">            </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_rect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CombineRect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a_branch</span><span class="p">.</span><span class="n">m_rect</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_rect</span><span class="p">));</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Child was split. The old branches are now re-partitioned to two nodes</span>
<span class="w">            </span><span class="c1">// so we have to re-calculate the bounding boxes of each node</span>
<span class="w">            </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_rect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NodeCover</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_child</span><span class="p">);</span>
<span class="w">            </span><span class="n">Branch</span><span class="w"> </span><span class="n">branch</span><span class="p">;</span>
<span class="w">            </span><span class="n">branch</span><span class="p">.</span><span class="n">m_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">otherNode</span><span class="p">;</span>
<span class="w">            </span><span class="n">branch</span><span class="p">.</span><span class="n">m_rect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NodeCover</span><span class="p">(</span><span class="n">otherNode</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// The old node is already a child of a_node. Now add the newly-created</span>
<span class="w">            </span><span class="c1">// node to a_node as well. a_node might be split because of that.</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">AddBranch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">branch</span><span class="p">,</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">a_newNode</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a_level</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// We have reached level for insertion. Add rect, split if necessary</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AddBranch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">a_newNode</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Should never occur</span>
<span class="w">        </span><span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Insert a data rectangle into an index structure.</span>
<span class="c1">// InsertRect provides for splitting the root;</span>
<span class="c1">// returns 1 if root was split, 0 if it was not.</span>
<span class="c1">// The level argument specifies the number of steps up from the leaf</span>
<span class="c1">// level to insert; e.g. a data rectangle goes in at level = 0.</span>
<span class="c1">// InsertRect2 does the recursion.</span>
<span class="c1">//</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">InsertRect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Branch</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">**</span><span class="w"> </span><span class="n">a_root</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_level</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_root</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_level</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a_level</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">a_root</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="p">);</span>
<span class="cp">#ifdef _DEBUG</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_branch</span><span class="p">.</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">a_branch</span><span class="p">.</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="cp">#endif </span><span class="c1">//_DEBUG</span>

<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">newNode</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">InsertRectRec</span><span class="p">(</span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">a_root</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">newNode</span><span class="p">,</span><span class="w"> </span><span class="n">a_level</span><span class="p">))</span><span class="w">  </span><span class="c1">// Root split</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Grow tree taller and new root</span>
<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">newRoot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AllocNode</span><span class="p">();</span>
<span class="w">        </span><span class="n">newRoot</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">a_root</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="n">Branch</span><span class="w"> </span><span class="n">branch</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// add old root node as a child of the new root</span>
<span class="w">        </span><span class="n">branch</span><span class="p">.</span><span class="n">m_rect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NodeCover</span><span class="p">(</span><span class="o">*</span><span class="n">a_root</span><span class="p">);</span>
<span class="w">        </span><span class="n">branch</span><span class="p">.</span><span class="n">m_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">a_root</span><span class="p">;</span>
<span class="w">        </span><span class="n">AddBranch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">branch</span><span class="p">,</span><span class="w"> </span><span class="n">newRoot</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// add the split node as a child of the new root</span>
<span class="w">        </span><span class="n">branch</span><span class="p">.</span><span class="n">m_rect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NodeCover</span><span class="p">(</span><span class="n">newNode</span><span class="p">);</span>
<span class="w">        </span><span class="n">branch</span><span class="p">.</span><span class="n">m_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newNode</span><span class="p">;</span>
<span class="w">        </span><span class="n">AddBranch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">branch</span><span class="p">,</span><span class="w"> </span><span class="n">newRoot</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// set the new root as the root node</span>
<span class="w">        </span><span class="o">*</span><span class="n">a_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newRoot</span><span class="p">;</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Find the smallest rectangle that includes all rectangles in branches of a node.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="k">typename</span><span class="w"> </span><span class="nc">RTREE_QUAL</span><span class="o">::</span><span class="n">Rect</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">NodeCover</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_node</span><span class="p">);</span>

<span class="w">    </span><span class="n">Rect</span><span class="w"> </span><span class="n">rect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m_rect</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">CombineRect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rect</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_rect</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rect</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">rect</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Add a branch to a node.  Split the node if necessary.</span>
<span class="c1">// Returns 0 if node not split.  Old node updated.</span>
<span class="c1">// Returns 1 if node split, sets *new_node to address of new node.</span>
<span class="c1">// Old node updated, becomes one of two.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">AddBranch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Branch</span><span class="o">*</span><span class="w"> </span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">**</span><span class="w"> </span><span class="n">a_newNode</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_branch</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_node</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAXNODES</span><span class="p">)</span><span class="w">  </span><span class="c1">// Split won&#39;t be necessary</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">a_branch</span><span class="p">;</span>
<span class="w">        </span><span class="o">++</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_newNode</span><span class="p">);</span>

<span class="w">        </span><span class="n">SplitNode</span><span class="p">(</span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="n">a_newNode</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Disconnect a dependent node.</span>
<span class="c1">// Caller must return (or stop using iteration index) after this as count has changed</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">DisconnectBranch</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_index</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_node</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">a_index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">a_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAXNODES</span><span class="p">));</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Remove element by swapping with the last element to prevent gaps in array</span>
<span class="w">    </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">a_index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>

<span class="w">    </span><span class="o">--</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Pick a branch.  Pick the one that will need the smallest increase</span>
<span class="c1">// in area to accomodate the new rectangle.  This will result in the</span>
<span class="c1">// least total area for the covering rectangles in the current node.</span>
<span class="c1">// In case of a tie, pick the one which was smaller before, to get</span>
<span class="c1">// the best resolution when searching.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">int</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">PickBranch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_rect</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a_node</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">firstTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">increase</span><span class="p">;</span>
<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">bestIncr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">)</span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">area</span><span class="p">;</span>
<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">bestArea</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">Rect</span><span class="w"> </span><span class="n">tempRect</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">curRect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_rect</span><span class="p">;</span>
<span class="w">        </span><span class="n">area</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalcRectVolume</span><span class="p">(</span><span class="n">curRect</span><span class="p">);</span>
<span class="w">        </span><span class="n">CombineRect</span><span class="p">(</span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="n">curRect</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tempRect</span><span class="p">);</span>
<span class="w">        </span><span class="n">increase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalcRectVolume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tempRect</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">area</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">increase</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bestIncr</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">firstTime</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">best</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">            </span><span class="n">bestArea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">area</span><span class="p">;</span>
<span class="w">            </span><span class="n">bestIncr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">increase</span><span class="p">;</span>
<span class="w">            </span><span class="n">firstTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">increase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">bestIncr</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">area</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bestArea</span><span class="p">))</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">best</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">            </span><span class="n">bestArea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">area</span><span class="p">;</span>
<span class="w">            </span><span class="n">bestIncr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">increase</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">best</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Combine two rectangles into larger one containing both</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="k">typename</span><span class="w"> </span><span class="nc">RTREE_QUAL</span><span class="o">::</span><span class="n">Rect</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">CombineRect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rectA</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rectB</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_rectA</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a_rectB</span><span class="p">);</span>

<span class="w">    </span><span class="n">Rect</span><span class="w"> </span><span class="n">newRect</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">newRect</span><span class="p">.</span><span class="n">m_min</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Min</span><span class="p">(</span><span class="n">a_rectA</span><span class="o">-&gt;</span><span class="n">m_min</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="w"> </span><span class="n">a_rectB</span><span class="o">-&gt;</span><span class="n">m_min</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
<span class="w">        </span><span class="n">newRect</span><span class="p">.</span><span class="n">m_max</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Max</span><span class="p">(</span><span class="n">a_rectA</span><span class="o">-&gt;</span><span class="n">m_max</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="w"> </span><span class="n">a_rectB</span><span class="o">-&gt;</span><span class="n">m_max</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">newRect</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Combine two rectangles into larger one containing both (output parameter version)</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">CombineRect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rectA</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rectB</span><span class="p">,</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_result</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_rectA</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a_rectB</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a_result</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">a_result</span><span class="o">-&gt;</span><span class="n">m_min</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Min</span><span class="p">(</span><span class="n">a_rectA</span><span class="o">-&gt;</span><span class="n">m_min</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="w"> </span><span class="n">a_rectB</span><span class="o">-&gt;</span><span class="n">m_min</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
<span class="w">        </span><span class="n">a_result</span><span class="o">-&gt;</span><span class="n">m_max</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Max</span><span class="p">(</span><span class="n">a_rectA</span><span class="o">-&gt;</span><span class="n">m_max</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="w"> </span><span class="n">a_rectB</span><span class="o">-&gt;</span><span class="n">m_max</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>



<span class="c1">// Split a node.</span>
<span class="c1">// Divides the nodes branches and the extra one between two nodes.</span>
<span class="c1">// Old node is one of the new ones, and one really new one is created.</span>
<span class="c1">// Tries more than one method for choosing a partition, uses best result.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">SplitNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Branch</span><span class="o">*</span><span class="w"> </span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">**</span><span class="w"> </span><span class="n">a_newNode</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_node</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_branch</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Could just use local here, but member or external is faster since it is reused</span>
<span class="w">    </span><span class="n">PartitionVars</span><span class="w"> </span><span class="n">localVars</span><span class="p">;</span>
<span class="w">    </span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">parVars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">localVars</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Load all the branches into a buffer, initialize old node</span>
<span class="w">    </span><span class="n">GetBranches</span><span class="p">(</span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="n">parVars</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Find partition</span>
<span class="w">    </span><span class="n">ChoosePartition</span><span class="p">(</span><span class="n">parVars</span><span class="p">,</span><span class="w"> </span><span class="n">MINNODES</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Create a new node to hold (about) half of the branches</span>
<span class="w">    </span><span class="o">*</span><span class="n">a_newNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AllocNode</span><span class="p">();</span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">a_newNode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Put branches from buffer into 2 nodes according to the chosen partition</span>
<span class="w">    </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">LoadNodes</span><span class="p">(</span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">a_newNode</span><span class="p">,</span><span class="w"> </span><span class="n">parVars</span><span class="p">);</span>

<span class="w">    </span><span class="n">ASSERT</span><span class="p">((</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">a_newNode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">// Calculate the n-dimensional volume of a rectangle</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">RectVolume</span><span class="p">(</span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_rect</span><span class="p">);</span>

<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">volume</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">volume</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">a_rect</span><span class="o">-&gt;</span><span class="n">m_max</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a_rect</span><span class="o">-&gt;</span><span class="n">m_min</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">volume</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">volume</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// The exact volume of the bounding sphere for the given Rect</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">RectSphericalVolume</span><span class="p">(</span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_rect</span><span class="p">);</span>

<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">sumOfSquares</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">radius</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">halfExtent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">ELEMTYPEREAL</span><span class="p">)</span><span class="n">a_rect</span><span class="o">-&gt;</span><span class="n">m_max</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">)</span><span class="n">a_rect</span><span class="o">-&gt;</span><span class="n">m_min</span><span class="p">[</span><span class="n">index</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">)</span><span class="mf">0.5</span><span class="p">;</span>
<span class="w">        </span><span class="n">sumOfSquares</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">halfExtent</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">halfExtent</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">radius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">)</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sumOfSquares</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Pow maybe slow, so test for common dims like 2,3 and just use x*x, x*x*x.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">NUMDIMS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m_unitSphereVolume</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">NUMDIMS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m_unitSphereVolume</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">)(</span><span class="n">pow</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m_unitSphereVolume</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Use one of the methods to calculate retangle volume</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">CalcRectVolume</span><span class="p">(</span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef RTREE_USE_SPHERICAL_VOLUME</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">RectSphericalVolume</span><span class="p">(</span><span class="n">a_rect</span><span class="p">);</span><span class="w"> </span><span class="c1">// Slower but helps certain merge cases</span>
<span class="cp">#else </span><span class="c1">// RTREE_USE_SPHERICAL_VOLUME</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">RectVolume</span><span class="p">(</span><span class="n">a_rect</span><span class="p">);</span><span class="w"> </span><span class="c1">// Faster but can cause poor merges</span>
<span class="cp">#endif </span><span class="c1">// RTREE_USE_SPHERICAL_VOLUME</span>
<span class="p">}</span>


<span class="c1">// Load branch buffer with branches from full node plus the extra branch.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">GetBranches</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Branch</span><span class="o">*</span><span class="w"> </span><span class="n">a_branch</span><span class="p">,</span><span class="w"> </span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_node</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_branch</span><span class="p">);</span>

<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAXNODES</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Load the branch buffer</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAXNODES</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="n">MAXNODES</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">a_branch</span><span class="p">;</span>
<span class="w">    </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAXNODES</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Calculate rect containing all in the set</span>
<span class="w">    </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_coverSplit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m_rect</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAXNODES</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">CombineRect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_coverSplit</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_rect</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_coverSplit</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_coverSplitArea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalcRectVolume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_coverSplit</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">// Method #0 for choosing a partition:</span>
<span class="c1">// As the seeds for the two groups, pick the two rects that would waste the</span>
<span class="c1">// most area if covered by a single rectangle, i.e. evidently the worst pair</span>
<span class="c1">// to have in the same group.</span>
<span class="c1">// Of the remaining, one at a time is chosen to be put in one of the two groups.</span>
<span class="c1">// The one chosen is the one with the greatest difference in area expansion</span>
<span class="c1">// depending on which group - the rect most strongly attracted to one group</span>
<span class="c1">// and repelled from the other.</span>
<span class="c1">// If one group gets too full (more would force other group to violate min</span>
<span class="c1">// fill requirement) then other group gets the rest.</span>
<span class="c1">// These last are the ones that can go in either group most easily.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">ChoosePartition</span><span class="p">(</span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_minFill</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_parVars</span><span class="p">);</span>

<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">biggestDiff</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">chosen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">betterGroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">InitParVars</span><span class="p">(</span><span class="n">a_parVars</span><span class="p">,</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchCount</span><span class="p">,</span><span class="w"> </span><span class="n">a_minFill</span><span class="p">);</span>
<span class="cp">#ifdef RTREE_USE_LINEAR_SPLIT</span>
<span class="w">    </span><span class="n">PickSeedsLinear</span><span class="p">(</span><span class="n">a_parVars</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">PickSeeds</span><span class="p">(</span><span class="n">a_parVars</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(((</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="p">)</span>
<span class="w">        </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_minFill</span><span class="p">))</span>
<span class="w">        </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_minFill</span><span class="p">)))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">biggestDiff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">)</span><span class="mi">-1</span><span class="p">;</span>
<span class="w">        </span><span class="n">Rect</span><span class="w"> </span><span class="n">rect0</span><span class="p">,</span><span class="w"> </span><span class="n">rect1</span><span class="p">;</span><span class="w">  </span><span class="c1">// Reused across iterations</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PartitionVars</span><span class="o">::</span><span class="n">NOT_TAKEN</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_partition</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">curRect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_rect</span><span class="p">;</span>
<span class="w">                </span><span class="n">CombineRect</span><span class="p">(</span><span class="n">curRect</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_cover</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rect0</span><span class="p">);</span>
<span class="w">                </span><span class="n">CombineRect</span><span class="p">(</span><span class="n">curRect</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_cover</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rect1</span><span class="p">);</span>
<span class="w">                </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">growth0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalcRectVolume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rect0</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_area</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">                </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">growth1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalcRectVolume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rect1</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_area</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">                </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">growth1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">growth0</span><span class="p">;</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">diff</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">                    </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">diff</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">diff</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">biggestDiff</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">biggestDiff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">diff</span><span class="p">;</span>
<span class="w">                    </span><span class="n">chosen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">                    </span><span class="n">betterGroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">diff</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">biggestDiff</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="n">betterGroup</span><span class="p">]))</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">chosen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">                    </span><span class="n">betterGroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">Classify</span><span class="p">(</span><span class="n">chosen</span><span class="p">,</span><span class="w"> </span><span class="n">betterGroup</span><span class="p">,</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If one group too full, put remaining rects in the other</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_minFill</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PartitionVars</span><span class="o">::</span><span class="n">NOT_TAKEN</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_partition</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">Classify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">ASSERT</span><span class="p">((</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">((</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_minFill</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">        </span><span class="p">(</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_minFill</span><span class="p">));</span>
<span class="p">}</span>


<span class="c1">// Copy branches from the buffer into two nodes according to the partition.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">LoadNodes</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_nodeA</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_nodeB</span><span class="p">,</span><span class="w"> </span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_nodeA</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_nodeB</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_parVars</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_partition</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_partition</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">targetNodeIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_partition</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">targetNodes</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a_nodeA</span><span class="p">,</span><span class="w"> </span><span class="n">a_nodeB</span><span class="w"> </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// It is assured that AddBranch here will not cause a node split.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">nodeWasSplit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddBranch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="w"> </span><span class="n">targetNodes</span><span class="p">[</span><span class="n">targetNodeIndex</span><span class="p">],</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">        </span><span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">nodeWasSplit</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Initialize a PartitionVars structure.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">InitParVars</span><span class="p">(</span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_maxRects</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_minFill</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_parVars</span><span class="p">);</span>

<span class="w">    </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_area</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_maxRects</span><span class="p">;</span>
<span class="w">    </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_minFill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_minFill</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_maxRects</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_partition</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PartitionVars</span><span class="o">::</span><span class="n">NOT_TAKEN</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">PickSeeds</span><span class="p">(</span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">seed0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">seed1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">worst</span><span class="p">,</span><span class="w"> </span><span class="n">waste</span><span class="p">;</span>
<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">area</span><span class="p">[</span><span class="n">MAXNODES</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">area</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalcRectVolume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_rect</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">worst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_coverSplitArea</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">indexA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">indexA</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">indexA</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">indexB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indexA</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">indexB</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">indexB</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Rect</span><span class="w"> </span><span class="n">oneRect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CombineRect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="n">indexA</span><span class="p">].</span><span class="n">m_rect</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="n">indexB</span><span class="p">].</span><span class="n">m_rect</span><span class="p">);</span>
<span class="w">            </span><span class="n">waste</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalcRectVolume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oneRect</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">area</span><span class="p">[</span><span class="n">indexA</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">area</span><span class="p">[</span><span class="n">indexB</span><span class="p">];</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">waste</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">worst</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">worst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">waste</span><span class="p">;</span>
<span class="w">                </span><span class="n">seed0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indexA</span><span class="p">;</span>
<span class="w">                </span><span class="n">seed1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indexB</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">Classify</span><span class="p">(</span><span class="n">seed0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">);</span>
<span class="w">    </span><span class="n">Classify</span><span class="p">(</span><span class="n">seed1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">// Linear time seed selection - O(NUMDIMS * n) instead of O(n²)</span>
<span class="c1">// Finds the most extreme entries along each dimension and picks the pair</span>
<span class="c1">// with the greatest normalized separation.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">PickSeedsLinear</span><span class="p">(</span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">seed0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">seed1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">maxNormalizedSeparation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">)</span><span class="mi">-1</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">dim</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Find entries with highest low and lowest high along this dimension</span>
<span class="w">        </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">highestLow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">[</span><span class="n">dim</span><span class="p">];</span>
<span class="w">        </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">lowestHigh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">[</span><span class="n">dim</span><span class="p">];</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">highestLowIdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">lowestHighIdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">overallLow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">highestLow</span><span class="p">;</span>
<span class="w">        </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">overallHigh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">[</span><span class="n">dim</span><span class="p">];</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_total</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_min</span><span class="p">[</span><span class="n">dim</span><span class="p">];</span>
<span class="w">            </span><span class="n">ELEMTYPE</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">m_rect</span><span class="p">.</span><span class="n">m_max</span><span class="p">[</span><span class="n">dim</span><span class="p">];</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">highestLow</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">highestLow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">low</span><span class="p">;</span>
<span class="w">                </span><span class="n">highestLowIdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">high</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">lowestHigh</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">lowestHigh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">high</span><span class="p">;</span>
<span class="w">                </span><span class="n">lowestHighIdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">overallLow</span><span class="p">)</span><span class="w"> </span><span class="n">overallLow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">low</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">high</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">overallHigh</span><span class="p">)</span><span class="w"> </span><span class="n">overallHigh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">high</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Calculate normalized separation for this dimension</span>
<span class="w">        </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">)(</span><span class="n">overallHigh</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">overallLow</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">ELEMTYPEREAL</span><span class="w"> </span><span class="n">separation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ELEMTYPEREAL</span><span class="p">)(</span><span class="n">highestLow</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">lowestHigh</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">separation</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">maxNormalizedSeparation</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">highestLowIdx</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">lowestHighIdx</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">maxNormalizedSeparation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">separation</span><span class="p">;</span>
<span class="w">                </span><span class="n">seed0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">highestLowIdx</span><span class="p">;</span>
<span class="w">                </span><span class="n">seed1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lowestHighIdx</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">Classify</span><span class="p">(</span><span class="n">seed0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">);</span>
<span class="w">    </span><span class="n">Classify</span><span class="p">(</span><span class="n">seed1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">// Put a branch in one of the groups.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">Classify</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a_index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_group</span><span class="p">,</span><span class="w"> </span><span class="n">PartitionVars</span><span class="o">*</span><span class="w"> </span><span class="n">a_parVars</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_parVars</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">PartitionVars</span><span class="o">::</span><span class="n">NOT_TAKEN</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_partition</span><span class="p">[</span><span class="n">a_index</span><span class="p">]);</span>

<span class="w">    </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_partition</span><span class="p">[</span><span class="n">a_index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_group</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Calculate combined rect</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="n">a_group</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_cover</span><span class="p">[</span><span class="n">a_group</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="n">a_index</span><span class="p">].</span><span class="n">m_rect</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_cover</span><span class="p">[</span><span class="n">a_group</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CombineRect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_branchBuf</span><span class="p">[</span><span class="n">a_index</span><span class="p">].</span><span class="n">m_rect</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_cover</span><span class="p">[</span><span class="n">a_group</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Calculate volume of combined rect</span>
<span class="w">    </span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_area</span><span class="p">[</span><span class="n">a_group</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalcRectVolume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_cover</span><span class="p">[</span><span class="n">a_group</span><span class="p">]);</span>

<span class="w">    </span><span class="o">++</span><span class="n">a_parVars</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">[</span><span class="n">a_group</span><span class="p">];</span>
<span class="p">}</span>


<span class="c1">// Delete a data rectangle from an index structure.</span>
<span class="c1">// Pass in a pointer to a Rect, the tid of the record, ptr to ptr to root node.</span>
<span class="c1">// Returns 1 if record not found, 0 if success.</span>
<span class="c1">// RemoveRect provides for eliminating the root.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">RemoveRect</span><span class="p">(</span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">**</span><span class="w"> </span><span class="n">a_root</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_rect</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a_root</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="o">*</span><span class="n">a_root</span><span class="p">);</span>

<span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">reInsertList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">RemoveRectRec</span><span class="p">(</span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">a_root</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">reInsertList</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Found and deleted a data item</span>
<span class="w">        </span><span class="c1">// Reinsert any branches from eliminated nodes</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">reInsertList</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">tempNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reInsertList</span><span class="o">-&gt;</span><span class="n">m_node</span><span class="p">;</span>

<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">tempNode</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// TODO go over this code. should I use (tempNode-&gt;m_level - 1)?</span>
<span class="w">                </span><span class="n">InsertRect</span><span class="p">(</span><span class="n">tempNode</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
<span class="w">                    </span><span class="n">a_root</span><span class="p">,</span>
<span class="w">                    </span><span class="n">tempNode</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">remLNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reInsertList</span><span class="p">;</span>
<span class="w">            </span><span class="n">reInsertList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reInsertList</span><span class="o">-&gt;</span><span class="n">m_next</span><span class="p">;</span>

<span class="w">            </span><span class="n">FreeNode</span><span class="p">(</span><span class="n">remLNode</span><span class="o">-&gt;</span><span class="n">m_node</span><span class="p">);</span>
<span class="w">            </span><span class="n">FreeListNode</span><span class="p">(</span><span class="n">remLNode</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Check for redundant root (not leaf, 1 child) and eliminate TODO replace</span>
<span class="w">        </span><span class="c1">// if with while? In case there is a whole branch of redundant roots...</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">a_root</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">a_root</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">IsInternalNode</span><span class="p">())</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">tempNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">a_root</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m_child</span><span class="p">;</span>

<span class="w">            </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">tempNode</span><span class="p">);</span>
<span class="w">            </span><span class="n">FreeNode</span><span class="p">(</span><span class="o">*</span><span class="n">a_root</span><span class="p">);</span>
<span class="w">            </span><span class="o">*</span><span class="n">a_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempNode</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Delete a rectangle from non-root part of an index structure.</span>
<span class="c1">// Called by RemoveRect.  Descends tree recursively,</span>
<span class="c1">// merges branches on the way back up.</span>
<span class="c1">// Returns 1 if record not found, 0 if success.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">RemoveRectRec</span><span class="p">(</span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">a_listNode</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_rect</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a_node</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a_listNode</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">IsInternalNode</span><span class="p">())</span><span class="w">  </span><span class="c1">// not a leaf node</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Overlap</span><span class="p">(</span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_rect</span><span class="p">)))</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">RemoveRectRec</span><span class="p">(</span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_child</span><span class="p">,</span><span class="w"> </span><span class="n">a_listNode</span><span class="p">))</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_child</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">MINNODES</span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="c1">// child removed, just resize parent rect</span>
<span class="w">                        </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_rect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NodeCover</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_child</span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="c1">// child removed, not enough entries in node, eliminate node</span>
<span class="w">                        </span><span class="n">ReInsert</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_child</span><span class="p">,</span><span class="w"> </span><span class="n">a_listNode</span><span class="p">);</span>
<span class="w">                        </span><span class="n">DisconnectBranch</span><span class="p">(</span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"> </span><span class="c1">// Must return after this call as count has changed</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="c1">// A leaf node</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a_id</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">DisconnectBranch</span><span class="p">(</span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"> </span><span class="c1">// Must return after this call as count has changed</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Decide whether two rectangles overlap.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">Overlap</span><span class="p">(</span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rectA</span><span class="p">,</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rectB</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_rectA</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a_rectB</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NUMDIMS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_rectA</span><span class="o">-&gt;</span><span class="n">m_min</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">a_rectB</span><span class="o">-&gt;</span><span class="n">m_max</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">||</span>
<span class="w">            </span><span class="n">a_rectB</span><span class="o">-&gt;</span><span class="n">m_min</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">a_rectA</span><span class="o">-&gt;</span><span class="n">m_max</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Add a node to the reinsertion list.  All its branches will later</span>
<span class="c1">// be reinserted into the index structure.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="kt">void</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">ReInsert</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">a_listNode</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">newListNode</span><span class="p">;</span>

<span class="w">    </span><span class="n">newListNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AllocListNode</span><span class="p">();</span>
<span class="w">    </span><span class="n">newListNode</span><span class="o">-&gt;</span><span class="n">m_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_node</span><span class="p">;</span>
<span class="w">    </span><span class="n">newListNode</span><span class="o">-&gt;</span><span class="n">m_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">a_listNode</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">a_listNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newListNode</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Search in an index tree or subtree for all data retangles that overlap the argument rectangle.</span>
<span class="n">RTREE_TEMPLATE</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">CALLBACK_TYPE</span><span class="o">&gt;</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">Search</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="n">Rect</span><span class="o">*</span><span class="w"> </span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_foundCount</span><span class="p">,</span><span class="w"> </span><span class="n">CALLBACK_TYPE</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_node</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">a_rect</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">IsInternalNode</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// This is an internal node in the tree</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Overlap</span><span class="p">(</span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_rect</span><span class="p">))</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Search</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_child</span><span class="p">,</span><span class="w"> </span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="n">a_foundCount</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">))</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="c1">// The callback indicated to stop searching</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// This is a leaf node</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Overlap</span><span class="p">(</span><span class="n">a_rect</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_rect</span><span class="p">))</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">DATATYPE</span><span class="o">&amp;</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_data</span><span class="p">;</span>
<span class="w">                </span><span class="o">++</span><span class="n">a_foundCount</span><span class="p">;</span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">callback</span><span class="p">(</span><span class="n">id</span><span class="p">))</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Don&#39;t continue searching</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Continue searching</span>
<span class="p">}</span>


<span class="n">RTREE_TEMPLATE</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RTREE_QUAL</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RTREE_QUAL</span><span class="o">::</span><span class="n">ListTree</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">m_root</span><span class="p">);</span>
<span class="w">    </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">m_root</span><span class="o">-&gt;</span><span class="n">m_level</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Rect</span><span class="o">&gt;</span><span class="w"> </span><span class="n">treeList</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">toVisit</span><span class="p">;</span>
<span class="w">    </span><span class="n">toVisit</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">m_root</span><span class="p">);</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">toVisit</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">a_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">toVisit</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
<span class="w">        </span><span class="n">toVisit</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">IsInternalNode</span><span class="p">())</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// This is an internal node in the tree</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">treeList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_rect</span><span class="p">);</span>
<span class="w">                </span><span class="n">toVisit</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_child</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// This is a leaf node</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">treeList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a_node</span><span class="o">-&gt;</span><span class="n">m_branch</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">m_rect</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">treeList</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#undef RTREE_TEMPLATE</span>
<span class="cp">#undef RTREE_QUAL</span>

<span class="cp">#endif </span><span class="c1">//RTREE_H</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Pelican Mapping.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>