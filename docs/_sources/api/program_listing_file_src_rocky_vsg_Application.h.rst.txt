
.. _program_listing_file_src_rocky_vsg_Application.h:

Program Listing for File Application.h
======================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_rocky_vsg_Application.h>` (``src/rocky/vsg/Application.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   #include <rocky/vsg/VSGContext.h>
   #include <rocky/vsg/MapNode.h>
   #include <rocky/vsg/SkyNode.h>
   #include <rocky/ecs/Registry.h>
   #include <rocky/vsg/ecs/ECSNode.h>
   #include <rocky/vsg/DisplayManager.h>
   #include <rocky/Callbacks.h>
   
   #include <chrono>
   #include <deque>
   #include <functional>
   #include <cstdint>
   
   namespace ROCKY_NAMESPACE
   {
       class RenderImGuiContext;
   
       class ROCKY_EXPORT Application
       {
       public:
           Application();
   
           Application(int& argc, char** argv);
   
           Application(vsg::ref_ptr<vsg::Viewer> viewer);
   
           Application(vsg::ref_ptr<vsg::Viewer> viewer, int& argc, char** argv);
   
           int run();
   
           bool frame();
   
           void onNextUpdate(std::function<void()> func);
   
           std::string about() const;
   
           bool debugLayerOn() const {
               return _debuglayer;
           }
   
           void realize();
   
           inline IOOptions& io();
   
           inline bool active() const;
   
           void install(vsg::ref_ptr<RenderImGuiContext>);
   
           std::uint64_t frameCount() const;
   
           inline bool ok() const;
   
       public: // public properties
   
           Registry registry = Registry::create();
   
           rocky::VSGContext vsgcontext;
   
           DisplayManager display;
   
           util::BackgroundServices background;
   
           vsg::ref_ptr<vsg::Viewer> viewer;
           vsg::ref_ptr<vsg::Group> root;
           vsg::ref_ptr<vsg::Group> mainScene;
           vsg::ref_ptr<rocky::MapNode> mapNode;
           vsg::ref_ptr<rocky::SkyNode> skyNode;
           vsg::ref_ptr<rocky::ECSNode> ecsNode;
   
           bool renderContinuously = false;
   
           bool autoCreateWindow = true;
   
           Status commandLineStatus;
   
           using IdleFunction = std::shared_ptr<std::function<void()>>;
           std::deque<IdleFunction> idleFunctions;
   
           struct Stats
           {
               std::chrono::microseconds frame;
               std::chrono::microseconds events;
               std::chrono::microseconds update;
               std::chrono::microseconds record;
               std::chrono::microseconds present;
               double memory;
   
           };
           Stats stats;
   
       public:
           Application(const Application&) = delete;
   
           Application(Application&&) = delete;
   
           ~Application();
   
           template<typename T>
           inline T* getSystem();
   
       private:
           bool _apilayer = false;
           bool _debuglayer = false;
           bool _debuglayerUnique = false;
           bool _vsync = true;
           bool _multithreaded = true;
           bool _viewerRealized = false;
           int _framesSinceLastRender = 0; // for non-continuous rendering
           bool _lastFrameOK = true;
           int _framesUntilStopRender = 2; // for non-continuous rendering
           CallbackSubs _subs;
   
           void ctor(int& argc, char** argv);
   
           void setupViewer(vsg::ref_ptr<vsg::Viewer> viewer);
           void install(vsg::ref_ptr<RenderImGuiContext>, bool installIdleFunction);
   
           friend class DisplayManager;
       };
   
   
       inline IOOptions& Application::io() {
           return vsgcontext->io;
       }
   
       inline bool Application::active() const {
           return _lastFrameOK;
       }
   
       inline bool Application::ok() const {
           return vsgcontext && vsgcontext->status.ok();
       }
   
       template<typename T>
       T* Application::getSystem() {
           if (!ecsNode) return nullptr;
           for(auto& child : ecsNode->children) {
               T* system = dynamic_cast<T*>(child.get());
               if (system) return system;
           }
           return nullptr;
       }
   }
   
