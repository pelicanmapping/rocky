
.. _program_listing_file_src_rocky_GeoImage.h:

Program Listing for File GeoImage.h
===================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_rocky_GeoImage.h>` (``src/rocky/GeoImage.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   
   #include <rocky/Common.h>
   #include <rocky/SRS.h>
   #include <rocky/GeoExtent.h>
   #include <rocky/Math.h>
   #include <rocky/Result.h>
   #include <rocky/Image.h>
   #include <rocky/Heightfield.h>
   
   namespace ROCKY_NAMESPACE
   {
       class Image;
       class GeoPoint;
   
       class ROCKY_EXPORT GeoImage
       {
       public:
   
           GeoImage();
           GeoImage(const GeoImage&) = default;
           GeoImage& operator=(const GeoImage&) = default;
           GeoImage(const GeoImage&& rhs) noexcept { *this = rhs; }
           GeoImage& operator=(GeoImage&&) noexcept;
   
           GeoImage(std::shared_ptr<Image> image, const GeoExtent& extent);
   
           virtual ~GeoImage() { }
   
           bool valid() const;
           operator bool() const { return valid(); }
   
           std::shared_ptr<Image> image() const;
   
           const GeoExtent& extent() const;
   
           const SRS& srs() const;
   
           void composite(const std::vector<GeoImage>& sources, const std::vector<float>& opacities = {});
   
           double getUnitsPerPixel() const;
   
           bool getCoord(int s, int t, double& out_x, double& out_y) const;
   
           bool getPixel(double x, double y, int& s, int& t) const;
   
           using ReadResult = Result<Image::Pixel, std::nullopt_t>;
   
           ReadResult read(const GeoPoint& p, int layer=0) const;
   
           ReadResult read(double x, double y, int layer=0) const;
   
           ReadResult read_clamped(double x, double y, int layer=0) const;
   
           ReadResult read(const SRS& srs, double x, double y, int layer=0) const;
   
           ReadResult read(const SRSOperation& operation, double x, double y, int layer=0) const;
   
       private:
           GeoExtent _extent;
           std::shared_ptr<Image> _image;
       };
   
       class GeoHeightfield
       {
       public:
           using ReadResult = Result<float, std::nullopt_t>;
   
           GeoHeightfield(const GeoImage& in_image) :
               image(in_image), hf(in_image.image()) {
           }
   
           const GeoImage& image;
           Heightfield hf;
   
           ReadResult read(double x, double y) const {
               if (!image.valid()) return ResultFail;
               double u = (x - image.extent().xmin()) / image.extent().width();
               double v = (y - image.extent().ymin()) / image.extent().height();
               if (u < 0.0 || u > 1.0 || v < 0.0 || v > 1.0)
                   return ResultFail;
               return hf.heightAtUV((float)u, (float)v);
           }
       };
   }
