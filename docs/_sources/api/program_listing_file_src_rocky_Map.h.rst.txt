
.. _program_listing_file_src_rocky_Map.h:

Program Listing for File Map.h
==============================

|exhale_lsh| :ref:`Return to documentation for file <file_src_rocky_Map.h>` (``src/rocky/Map.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   
   #include <rocky/Common.h>
   #include <rocky/Layer.h>
   #include <rocky/Callbacks.h>
   #include <rocky/IOTypes.h>
   #include <shared_mutex>
   #include <vector>
   
   namespace ROCKY_NAMESPACE
   {
       class ROCKY_EXPORT Map : public Inherit<Object, Map>
       {
       public:
           using Layers = std::vector<Layer::Ptr>;
           
           Map() = default;
   
           void add(Layer::Ptr layer);
   
           void setLayers(const Layers& layers);
   
           void setLayers(Layers&& layers) noexcept;
   
           template<typename T = Layer, typename PREDICATE = std::function<bool(typename T::ConstPtr)>>
           inline std::vector<typename T::Ptr> layers(PREDICATE&& pred = [](typename T::ConstPtr) { return true; }) const;
   
           template<typename T = Layer, typename PREDICATE = std::function<bool(typename T::ConstPtr)>>
           inline typename T::Ptr layer(PREDICATE&& pred = [](typename T::ConstPtr) { return true; }) const;
   
           template<typename T = Layer, typename CALLABLE>
           inline void each(CALLABLE&&) const;
   
           Result<> openAllLayers(const IOOptions& options);
   
           Revision revision() const;
   
           Result<> from_json(std::string_view value, const IOOptions& io);
   
           std::string to_json() const;
   
       public:
           Callback<void(const Map*)> onLayersChanged;
   
       private:
           mutable std::shared_mutex _mutex;
           Revision _revision = 0;
           std::vector<Layer::Ptr> _layers;
       };
   
   
   
       // inlines
       template<class T, class PREDICATE>
       inline std::vector<typename T::Ptr> Map::layers(PREDICATE&& pred) const
       {
           static_assert(std::is_invocable_r_v<bool, PREDICATE, typename T::Ptr>,
               "Map::layers() requires a predicate matching the signature bool(T::ConstPtr)");
   
           std::vector<typename T::Ptr> result;
           std::shared_lock lock(_mutex);
           for (auto& layer : _layers)
           {
               typename T::Ptr typed = T::cast(layer);
               if (typed && pred(typed))
               {
                   result.emplace_back(typed);
               }
           }
           return result;
       }
   
       template<class T, class PREDICATE>
       inline typename T::Ptr Map::layer(PREDICATE&& pred) const
       {
           static_assert(std::is_invocable_r_v<bool, PREDICATE, typename T::Ptr>,
               "Map::layer() requires a predicate matching the signature bool(T::ConstPtr)");
   
           typename T::Ptr result;
           std::shared_lock lock(_mutex);
           for (auto& layer : _layers)
           {
               typename T::Ptr typed = T::cast(layer);
               if (typed && pred(typed))
                   return typed;
           }
           return {};
       }
   
       template<typename T, typename CALLABLE>
       inline void Map::each(CALLABLE&& func) const
       {
           static_assert(std::is_invocable_r_v<void, CALLABLE, typename T::Ptr>,
               "Map::each() requires a callable that takes a Layer::Ptr and returns void");
   
           std::shared_lock lock(_mutex);
           for (const auto& layer : _layers)
           {
               typename T::Ptr typed = T::cast(layer);
               if (typed)
                   func(typed);
           }
       }
   }
   
