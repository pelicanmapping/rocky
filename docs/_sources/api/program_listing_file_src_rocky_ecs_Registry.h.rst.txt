
.. _program_listing_file_src_rocky_ecs_Registry.h:

Program Listing for File Registry.h
===================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_rocky_ecs_Registry.h>` (``src/rocky/ecs/Registry.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   #include <rocky/Common.h>
   #include <chrono>
   #include <type_traits>
   #include <shared_mutex>
   #include <mutex>
   #include <utility> // std::pair
   #include <entt/entt.hpp>
   
   namespace ROCKY_NAMESPACE
   {
       using time_point = std::chrono::steady_clock::time_point;
   
       class Registry
       {
       public:
           struct Read {
               std::shared_lock<std::shared_mutex> lock;
               entt::registry& registry;
               entt::registry* operator->() { return &registry; }
               operator std::pair<std::shared_lock<std::shared_mutex>, entt::registry&>() { return { std::move(lock), registry }; }
           };
   
           struct Write {
               std::unique_lock<std::shared_mutex> lock;
               entt::registry& registry;
               entt::registry* operator->() { return &registry; }
               operator std::pair<std::unique_lock<std::shared_mutex>, entt::registry&>() { return { std::move(lock), registry }; }
           };
   
           inline Read read() const {
               return { std::shared_lock(_impl->_mutex), _impl->_registry };
           }
   
           inline Write write() const {
               return { std::unique_lock(_impl->_mutex), _impl->_registry };
           }
   
           template<typename CALLABLE>
           inline void read(CALLABLE&& func) const {
               static_assert(std::is_invocable_r_v<void, CALLABLE, entt::registry&>, "Callable must match void(entt::registry&)");
               auto [lock, registry] = read();
               func(registry);
           }
   
           template<typename CALLABLE>
           inline void write(CALLABLE&& func) const {
               static_assert(std::is_invocable_r_v<void, CALLABLE, entt::registry&>, "Callable must match void(entt::registry&)");
               auto [lock, registry] = write();
               func(registry);
           }
   
           Registry() = default;
   
           Registry(const Registry& rhs) = default;
   
           static Registry create() {
               Registry r;
               r._impl = std::make_shared<Impl>();
               return r;
           }
   
       private:
           struct Impl {
               mutable std::shared_mutex _mutex;
               mutable entt::registry _registry;
           };
           std::shared_ptr<Impl> _impl;
       };
   }
