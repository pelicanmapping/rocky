
.. _program_listing_file_src_rocky_Math.h:

Program Listing for File Math.h
===============================

|exhale_lsh| :ref:`Return to documentation for file <file_src_rocky_Math.h>` (``src/rocky/Math.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   
   #include <rocky/Common.h>
   #include <glm/ext.hpp>
   #include <tuple>
   #include <algorithm>
   
   #ifndef M_PI
   #define M_PI 3.14159265358979323846
   #endif
   
   namespace ROCKY_NAMESPACE
   {
       enum class Interpolation
       {
           Nearest,
           Average,
           Bilinear,
           Triangulate,
           Cubic,
           CubicSpline
       };
   
       // mult a vec3 x mat4
       inline glm::dvec3 operator * (const glm::dvec3& a, const glm::dmat4& b)
       {
           return glm::dvec3(glm::dvec4(a, 1) * b);
       }    
       inline glm::fvec3 operator * (const glm::fvec3& a, const glm::fmat4& b)
       {
           return glm::fvec3(glm::fvec4(a, 1) * b);
       }
   
       inline glm::fvec3 operator * (const glm::fmat4& mat, const glm::fvec3& v) {
           return glm::fvec3(mat * glm::fvec4(v, 1));
       }
   
       inline glm::dvec3 operator * (const glm::dmat4& mat, const glm::dvec3& v) {
           return glm::dvec3(mat * glm::dvec4(v, 1));
       }
   
       template<typename SPHERE>
       inline SPHERE& expandBy(SPHERE& s, typename SPHERE::vec_type p)
       {
           if (s.radius >= 0.0)
           {
               auto dv = p - s.center;
               double r = glm::length(to_glm(dv));
               if (r > s.radius)
               {
                   double dr = 0.5 * (r - s.radius);
                   s.center += dv * (dr / r);
                   s.radius += dr;
               }
           }
           else
           {
               s.center = p;
               s.radius = 0.0;
           }
           return s;
       }
   
       struct ROCKY_EXPORT Sphere
       {
           glm::dvec3 center = { 0, 0, 0 };
           double radius = -1;
   
           Sphere() = default;
   
           template<class VEC3>
           Sphere(const VEC3& a, double r) :
               center(a.x, a.y, a.z), radius(r) { }
   
           template<class VEC3>
           inline void expandBy(const VEC3& v) {
               if (valid()) {
                   auto dv = glm::dvec3(v.x, v.y, v.z) - center;
                   double r = glm::length(dv);
                   if (r > radius) {
                       double dr = 0.5*(r - radius);
                       center += dv * (dr / r);
                       radius += dr;
                   }
               }
               else {
                   center.x = v.x, center.y = v.y, center.z = v.z;
                   radius = 0.0;
               }
           }
   
           inline bool valid() const {
               return radius >= 0.0;
           }
       };
   
       struct ROCKY_EXPORT Rect
       {
           Rect() = default;
   
           Rect(double x0, double y0, double x1, double y1) :
               xmin(x0), ymin(y0), xmax(x1), ymax(y1) { }
   
           Rect(double width, double height) :
               xmin(-width*0.5), ymin(-height*0.5), xmax(width*0.5), ymax(height*0.5) { }
   
           double xmin = 0.0, ymin = 0.0;
           double xmax = 0.0, ymax = 0.0;
   
           inline double width() const {
               return xmax - xmin;
           }
           inline double height() const {
               return ymax - ymin;
           }
       };
   
       struct ROCKY_EXPORT Box
       {        
           double xmin = DBL_MAX, ymin = DBL_MAX, zmin = DBL_MAX;
           double xmax = -DBL_MAX, ymax = -DBL_MAX, zmax = -DBL_MAX;
   
           inline double width() const {
               return xmax - xmin;
           }
           inline double height() const {
               return ymax - ymin;
           }
           inline double area2d() const {
               return width()*height();
           }
           inline glm::dvec3 center() const {
               return glm::dvec3(
                   xmin + 0.5*(xmax - xmin),
                   ymin + 0.5*(ymax - ymin),
                   zmin + 0.5*(zmax - zmin));
           }
           bool intersects(const Box& rhs) const {
               bool exclusive =
                   xmin > rhs.xmax || xmax < rhs.xmin ||
                   ymin > rhs.ymax || ymax < rhs.ymin ||
                   zmin > rhs.zmax || zmax < rhs.zmin;
               return !exclusive;
           }
           Box intersection_with(const Box&) const;
   
           Box union_with(const Box&) const;
   
           bool contains(const Box&) const;
   
           void expandBy(const glm::dvec3& p) {
               xmin = std::min(xmin, p.x);
               xmax = std::max(xmax, p.x);
               ymin = std::min(ymin, p.y);
               ymax = std::max(ymax, p.y);
               zmin = std::min(zmin, p.z);
               zmax = std::max(zmax, p.z);
           }
   
           void expandBy(const Box& rhs) {
               xmin = std::min(xmin, rhs.xmin);
               xmax = std::max(xmax, rhs.xmax);
               ymin = std::min(ymin, rhs.ymin);
               ymax = std::max(ymax, rhs.ymax);
               zmin = std::min(zmin, rhs.zmin);
               zmax = std::max(zmax, rhs.zmax);
           }
   
           inline bool clamp(double& x, double& y, double& z) const {
               bool clamped = false;
               if (x < xmin) { x = xmin; clamped = true; }
               else if (x > xmax) { x = xmax; clamped = true; }
               if (y < ymin) { y = ymin; clamped = true; }
               else if (y > ymax) { y = ymax; clamped = true; }
               if (z < zmin) { z = zmin; clamped = true; }
               else if (z > zmax) { z = zmax; clamped = true; }
               return clamped;
           }
   
           inline bool clamp(Box& rhs) const {
               bool ok1 = clamp(rhs.xmin, rhs.ymin, rhs.zmin);
               bool ok2 = clamp(rhs.xmax, rhs.ymax, rhs.zmax);
               return ok1 || ok2;
           }
   
           template<class ITER>
           void expandBy(ITER begin, ITER end) {
               for (ITER i = begin; i != end; ++i)
                   expandBy({ i->x, i->y, i->z });
           }
   
           glm::dvec3 corner(unsigned i) const {
               return glm::dvec3(
                   (i & 0x1) ? xmax : xmin,
                   (i & 0x2) ? ymax : ymin,
                   (i & 0x4) ? zmax : zmin);
           }
   
           void expandBy(const Sphere& rhs) {
               expandBy(Box(
                   rhs.center.x - rhs.radius, rhs.center.x + rhs.radius,
                   rhs.center.y - rhs.radius, rhs.center.y + rhs.radius,
                   rhs.center.z - rhs.radius, rhs.center.z + rhs.radius));
           }
   
           bool valid() const {
               return
                   xmin <= xmax &&
                   ymin <= ymax &&
                   zmin <= zmax;
           }
   
           bool operator == (const Box& rhs) const {
               return
                   xmin == rhs.xmin &&
                   ymin == rhs.ymin &&
                   zmin == rhs.zmin &&
                   xmax == rhs.xmax &&
                   ymax == rhs.ymax &&
                   zmax == rhs.zmax;
           }
   
           bool operator != (const Box& rhs) const {
               return
                   xmin != rhs.xmin ||
                   ymin != rhs.ymin ||
                   zmin != rhs.zmin ||
                   xmax != rhs.xmax ||
                   ymax != rhs.ymax ||
                   zmax != rhs.zmax;
           }
   
           Box() = default;
           Box(const Box&) = default;
   
           Box(double x0, double y0, double z0, double x1, double y1, double z1) :
               xmin(x0), ymin(y0), zmin(z0),
               xmax(x1), ymax(y1), zmax(z1) { }
   
           Box(double x0, double y0, double x1, double y1) :
               xmin(x0), ymin(y0), zmin(0.0),
               xmax(x1), ymax(y1), zmax(0.0) { }
       };
   
       template<int C, int R, typename T, glm::qualifier Q>
       inline bool is_identity(const glm::mat<C, R, T, Q>& m) {
           for (int c = 0; c < C; ++c) {
               for (int r = 0; r < R; ++r) {
                   if ((c == r && !glm::epsilonEqual(m[c][r], static_cast<T>(1), static_cast<T>(1e-6))) ||
                       (c != r && !glm::epsilonEqual(m[c][r], static_cast<T>(0), static_cast<T>(1e-6)))) {
                       return false;
                   }
               }
           }
           return true;
       }
   
       template<typename Q = glm::dquat>
       inline Q quaternion_from_euler_radians(double xaxis, double yaxis, double zaxis)
       {
           Q q;
   
           // x-axis rotation:
           double cx = cos(xaxis * 0.5);
           double sx = sin(xaxis * 0.5);
           // y-axis rotation:
           double cy = cos(yaxis * 0.5);
           double sy = sin(yaxis * 0.5);
           // z-axis rotation:
           double cz = cos(zaxis * 0.5);
           double sz = sin(zaxis * 0.5);
   
           q.w = cx * cy * cz + sx * sy * sz;
           q.x = sx * cy * cz - cx * sy * sz;
           q.y = cx * sy * cz + sx * cy * sz;
           q.z = cx * cy * sz - sx * sy * cz;
   
           return q;
       }
   
       template<typename Q = glm::dquat>
       inline Q quaternion_from_euler_degrees(double xaxis, double yaxis, double zaxis)
       {
           return quaternion_from_euler_radians<Q>(glm::radians(xaxis), glm::radians(yaxis), glm::radians(zaxis));
       }
   
       template<typename Q = glm::dquat>
       inline std::tuple<double, double, double> euler_radians_from_quaternion(const Q& q)
       {
           // x-axis rotation
           double sinr_cosp = 2 * (q.w * q.x + q.y * q.z);
           double cosr_cosp = 1 - 2 * (q.x * q.x + q.y * q.y);
           double xaxis = std::atan2(sinr_cosp, cosr_cosp);
           // y-axis rotation
           double sinp = std::sqrt(1 + 2 * (q.w * q.y - q.x * q.z));
           double cosp = std::sqrt(1 - 2 * (q.w * q.y - q.x * q.z));
           double yaxis = (2 * std::atan2(sinp, cosp) - M_PI / 2);
           // z-axis rotation
           double siny_cosp = 2 * (q.w * q.z + q.x * q.y);
           double cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
           double zaxis = std::atan2(siny_cosp, cosy_cosp);
   
           return std::make_tuple(xaxis, yaxis, zaxis);
       }
   
       template<typename Q>
       inline std::tuple<double, double, double> euler_degrees_from_quaternion(const Q& q)
       {
           auto a = euler_radians_from_quaternion(q);
           return std::make_tuple(glm::degrees(std::get<0>(a)), glm::degrees(std::get<1>(a)), glm::degrees(std::get<2>(a)));
       }
   
       template<typename Q, typename M>
       inline Q quaternion_from_unscaled_matrix(const M& _mat)
       {
           Q q;
   
           // from OpenSceneGraph:
           double s;
           double tq[4];
           int i, j;
   
           // Use tq to store the largest trace
           tq[0] = 1 + _mat[0][0] + _mat[1][1] + _mat[2][2];
           tq[1] = 1 + _mat[0][0] - _mat[1][1] - _mat[2][2];
           tq[2] = 1 - _mat[0][0] + _mat[1][1] - _mat[2][2];
           tq[3] = 1 - _mat[0][0] - _mat[1][1] + _mat[2][2];
   
           // Find the maximum (could also use stacked if's later)
           j = 0;
           for (i = 1; i < 4; i++) j = (tq[i] > tq[j]) ? i : j;
   
           // check the diagonal
           if (j == 0)
           {
               /* perform instant calculation */
               q.w = tq[0];
               q.x = _mat[1][2] - _mat[2][1];
               q.y = _mat[2][0] - _mat[0][2];
               q.z = _mat[0][1] - _mat[1][0];
           }
           else if (j == 1)
           {
               q.w = _mat[1][2] - _mat[2][1];
               q.x = tq[1];
               q.y = _mat[0][1] + _mat[1][0];
               q.z = _mat[2][0] + _mat[0][2];
           }
           else if (j == 2)
           {
               q.w = _mat[2][0] - _mat[0][2];
               q.x = _mat[0][1] + _mat[1][0];
               q.y = tq[2];
               q.z = _mat[1][2] + _mat[2][1];
           }
           else /* if (j==3) */
           {
               q.w = _mat[0][1] - _mat[1][0];
               q.x = _mat[2][0] + _mat[0][2];
               q.y = _mat[1][2] + _mat[2][1];
               q.z = tq[3];
           }
   
           s = sqrt(0.25 / tq[j]);
           q.w *= s;
           q.x *= s;
           q.y *= s;
           q.z *= s;
   
           return q;
       }
   
       template<typename Q, typename M>
       inline Q quaternion_from_matrix(const M& mat)
       {
           M _mat = mat;
   
           // Remove the scaling from the matrix by normalizing each axis
           double scaleX = sqrt(_mat[0][0] * _mat[0][0] + _mat[0][1] * _mat[0][1] + _mat[0][2] * _mat[0][2]);
           double scaleY = sqrt(_mat[1][0] * _mat[1][0] + _mat[1][1] * _mat[1][1] + _mat[1][2] * _mat[1][2]);
           double scaleZ = sqrt(_mat[2][0] * _mat[2][0] + _mat[2][1] * _mat[2][1] + _mat[2][2] * _mat[2][2]);
   
           _mat[0][0] /= scaleX; _mat[0][1] /= scaleX; _mat[0][2] /= scaleX;
           _mat[1][0] /= scaleY; _mat[1][1] /= scaleY; _mat[1][2] /= scaleY;
           _mat[2][0] /= scaleZ; _mat[2][1] /= scaleZ; _mat[2][2] /= scaleZ;
   
           return quaternion_from_unscaled_matrix<Q>(_mat);
       }
   
   #define ROCKY_FAST_MAT4_MULT(OUT, LHS, RHS) { \
       OUT[0][0] = LHS[0][0] * RHS[0][0] + LHS[1][0] * RHS[0][1] + LHS[2][0] * RHS[0][2] + LHS[3][0] * RHS[0][3], \
       OUT[0][1] = LHS[0][1] * RHS[0][0] + LHS[1][1] * RHS[0][1] + LHS[2][1] * RHS[0][2] + LHS[3][1] * RHS[0][3], \
       OUT[0][2] = LHS[0][2] * RHS[0][0] + LHS[1][2] * RHS[0][1] + LHS[2][2] * RHS[0][2] + LHS[3][2] * RHS[0][3], \
       OUT[0][3] = LHS[0][3] * RHS[0][0] + LHS[1][3] * RHS[0][1] + LHS[2][3] * RHS[0][2] + LHS[3][3] * RHS[0][3], \
       OUT[1][0] = LHS[0][0] * RHS[1][0] + LHS[1][0] * RHS[1][1] + LHS[2][0] * RHS[1][2] + LHS[3][0] * RHS[1][3], \
       OUT[1][1] = LHS[0][1] * RHS[1][0] + LHS[1][1] * RHS[1][1] + LHS[2][1] * RHS[1][2] + LHS[3][1] * RHS[1][3], \
       OUT[1][2] = LHS[0][2] * RHS[1][0] + LHS[1][2] * RHS[1][1] + LHS[2][2] * RHS[1][2] + LHS[3][2] * RHS[1][3], \
       OUT[1][3] = LHS[0][3] * RHS[1][0] + LHS[1][3] * RHS[1][1] + LHS[2][3] * RHS[1][2] + LHS[3][3] * RHS[1][3], \
       OUT[2][0] = LHS[0][0] * RHS[2][0] + LHS[1][0] * RHS[2][1] + LHS[2][0] * RHS[2][2] + LHS[3][0] * RHS[2][3], \
       OUT[2][1] = LHS[0][1] * RHS[2][0] + LHS[1][1] * RHS[2][1] + LHS[2][1] * RHS[2][2] + LHS[3][1] * RHS[2][3], \
       OUT[2][2] = LHS[0][2] * RHS[2][0] + LHS[1][2] * RHS[2][1] + LHS[2][2] * RHS[2][2] + LHS[3][2] * RHS[2][3], \
       OUT[2][3] = LHS[0][3] * RHS[2][0] + LHS[1][3] * RHS[2][1] + LHS[2][3] * RHS[2][2] + LHS[3][3] * RHS[2][3], \
       OUT[3][0] = LHS[0][0] * RHS[3][0] + LHS[1][0] * RHS[3][1] + LHS[2][0] * RHS[3][2] + LHS[3][0] * RHS[3][3], \
       OUT[3][1] = LHS[0][1] * RHS[3][0] + LHS[1][1] * RHS[3][1] + LHS[2][1] * RHS[3][2] + LHS[3][1] * RHS[3][3], \
       OUT[3][2] = LHS[0][2] * RHS[3][0] + LHS[1][2] * RHS[3][1] + LHS[2][2] * RHS[3][2] + LHS[3][2] * RHS[3][3], \
       OUT[3][3] = LHS[0][3] * RHS[3][0] + LHS[1][3] * RHS[3][1] + LHS[2][3] * RHS[3][2] + LHS[3][3] * RHS[3][3]; }
   
   #define ROCKY_MAT4_IS_IDENTITY(M) \
       (M[0][0] == 1.0 && M[0][1] == 0.0 && M[0][2] == 0.0 && M[0][3] == 0.0 && \
        M[1][0] == 0.0 && M[1][1] == 1.0 && M[1][2] == 0.0 && M[1][3] == 0.0 && \
        M[2][0] == 0.0 && M[2][1] == 0.0 && M[2][2] == 1.0 && M[2][3] == 0.0 && \
        M[3][0] == 0.0 && M[3][1] == 0.0 && M[3][2] == 0.0 && M[3][3] == 1.0)
   
   #define ROCKY_MAT4_IS_NOT_IDENTITY(M) \
       (M[0][0] != 1.0 || M[0][1] != 0.0 || M[0][2] != 0.0 || M[0][3] != 0.0 || \
        M[1][0] != 0.0 || M[1][1] != 1.0 || M[1][2] != 0.0 || M[1][3] != 0.0 || \
        M[2][0] != 0.0 || M[2][1] != 0.0 || M[2][2] != 1.0 || M[2][3] != 0.0 || \
        M[3][0] != 0.0 || M[3][1] != 0.0 || M[3][2] != 0.0 || M[3][3] != 1.0)
   
   #define ROCKY_MAT4_EQUAL(A,B) \
       (A[0][0] == B[0][0] && A[0][1] == B[0][1] && A[0][2] == B[0][2] && A[0][3] == B[0][3] && \
        A[1][0] == B[1][0] && A[1][1] == B[1][1] && A[1][2] == B[1][2] && A[1][3] == B[1][3] && \
        A[2][0] == B[2][0] && A[2][1] == B[2][1] && A[2][2] == B[2][2] && A[2][3] == B[2][3] && \
        A[3][0] == B[3][0] && A[3][1] == B[3][1] && A[3][2] == B[3][2] && A[3][3] == B[3][3])
   }
