
.. _program_listing_file_src_rocky_Heightfield.h:

Program Listing for File Heightfield.h
======================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_rocky_Heightfield.h>` (``src/rocky/Heightfield.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   
   #include <rocky/Image.h>
   
   namespace ROCKY_NAMESPACE
   {
       constexpr float NO_DATA_VALUE = -std::numeric_limits<float>::max();
       constexpr Image::PixelFormat HF_WRITABLE_FORMAT = Image::R32_SFLOAT;
       constexpr Image::PixelFormat HF_ENCODED_FORMAT = Image::R16_UNORM;
   
       class Heightfield
       {
       public:
           using EncodedDataType = std::uint16_t;
   
   
           static Heightfield create(unsigned cols, unsigned rows) {
               return Heightfield(cols, rows);
           }
   
           Heightfield(Image::Ptr in_image) : image(in_image)
           {
               ROCKY_SOFT_ASSERT(image);
               ROCKY_SOFT_ASSERT(image->pixelFormat() == HF_WRITABLE_FORMAT || image->pixelFormat() == HF_ENCODED_FORMAT);
               _writable = image->pixelFormat() == HF_WRITABLE_FORMAT;
           }
           
           Heightfield(unsigned cols, unsigned rows)
           {
               image = Image::create(HF_WRITABLE_FORMAT, cols, rows, 1);
               _writable = true;
           }
   
           Image::Ptr image = nullptr;
   
           inline float& heightAt(unsigned col, unsigned row);
   
           inline float heightAt(unsigned col, unsigned row) const;
   
           inline float heightAtUV(float u, float v) const;
   
           template<typename CALLABLE>
           inline void forEachHeight(CALLABLE&& func);
   
           template<typename CALLABLE>
           inline void forEachHeight(CALLABLE&& func) const;
   
           inline void fill(float value);
   
           inline unsigned width() const { return image->width(); }
   
           inline unsigned height() const { return image->height(); }
   
           inline float noDataValue() const { return image->noDataValue(); }
   
           inline float minHeight() const { return image->_minValue; }
   
           inline float maxHeight() const { return image->_maxValue; }
   
           inline Heightfield encode() const;
   
           inline bool encoded() const;
   
           inline void computeAndSetMinMax();
   
           inline std::pair<float, float> computeMinMax() const;
   
       private:
           bool _writable = true;
           template<typename T> inline float decode(T v) const;
       };
   
       // inline functions
   
       template<typename T>
       inline float Heightfield::decode(T v) const
       {
           // decodes the [0..1] value from an encoded normalized image into a real height.
           return static_cast<float>(v) == 1.0f? NO_DATA_VALUE : 
               static_cast<float>(v) * (image->_maxValue - image->_minValue) + image->_minValue;
       }
   
       inline float& Heightfield::heightAt(unsigned c, unsigned r)
       {
           static float empty = 0;
           ROCKY_HARD_ASSERT(_writable);
           ROCKY_SOFT_ASSERT_AND_RETURN(_writable, empty);
           return image->value<float>(c, r);
       }
   
       inline float Heightfield::heightAt(unsigned c, unsigned r) const
       {
           return _writable ?
               image->read(c, r).r :
               decode(image->read(c, r).r);
       }
   
       inline float Heightfield::heightAtUV(float u, float v) const
       {
           return _writable ?
               image->read_bilinear(u, v).r :
               decode(image->read_bilinear(u, v).r);
       }
   
       template<typename CALLABLE>
       inline void Heightfield::forEachHeight(CALLABLE&& func)
       {
           ROCKY_SOFT_ASSERT_AND_RETURN(_writable, void());
   
           auto* ptr = image->data<float>();
               for (auto i = 0u; i < image->sizeInPixels(); ++i, ++ptr)
                   func(*ptr);
       }
   
       template<typename CALLABLE>
       inline void Heightfield::forEachHeight(CALLABLE&& func) const
       {
           static_assert(std::is_invocable_v<CALLABLE, float>, "Callable must be invocable with a float argument");
   
           image->eachPixel([&](const Image::iterator& i)
               {
                   func(_writable ? image->read(i).r : decode(image->read(i).r));
               });
       }
       
       inline void Heightfield::fill(float value)
       {
           ROCKY_SOFT_ASSERT_AND_RETURN(_writable, void());
           float* ptr = image->data<float>();
           for (unsigned i = 0; i < image->sizeInPixels(); ++i)
               *ptr++ = value;
       }
   
       inline void Heightfield::computeAndSetMinMax()
       {
           ROCKY_SOFT_ASSERT_AND_RETURN(_writable, void());
           float& minH = image->_minValue;
           minH = std::numeric_limits<float>::max();
           float& maxH = image->_maxValue;
           maxH = -std::numeric_limits<float>::max();
           forEachHeight([&](float h)
               {
                   if (h != NO_DATA_VALUE) {
                       if (h < minH) minH = h;
                       if (h > maxH) maxH = h;
                   }
               });
           if (minH > maxH)
               minH = maxH = 0.0;
       }
   
       inline Heightfield Heightfield::encode() const
       {
           ROCKY_HARD_ASSERT(_writable, "Image must be writable");
           ROCKY_HARD_ASSERT(image->_maxValue >= image->_minValue, "Must call computeAndSetMinMax() before encoding");
   
           auto outImage = Image::create(HF_ENCODED_FORMAT, image->width(), image->height(), 1);
           outImage->_minValue = image->_minValue;
           outImage->_maxValue = image->_maxValue;
   
           auto* ptr = outImage->data<EncodedDataType>();
   
           constexpr EncodedDataType noDataEncodedValue = std::numeric_limits<EncodedDataType>::max();
   
           forEachHeight([&](float h)
               {
                   EncodedDataType value =
                       (h == NO_DATA_VALUE) ? noDataEncodedValue :
                       static_cast<EncodedDataType>(((h - image->_minValue) / (image->_maxValue - image->_minValue)) * (noDataEncodedValue-1));
   
                   *ptr++ = value;
               });
   
           return Heightfield(outImage);
       }
   
       inline bool Heightfield::encoded() const
       {
           return !_writable;
       }
   }
