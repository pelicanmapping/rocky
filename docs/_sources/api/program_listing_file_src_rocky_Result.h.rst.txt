
.. _program_listing_file_src_rocky_Result.h:

Program Listing for File Result.h
=================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_rocky_Result.h>` (``src/rocky/Result.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   
   #include <rocky/Common.h>
   #include <string>
   #include <variant>
   #include <optional>
   
   namespace ROCKY_NAMESPACE
   {
       struct Failure
       {
           enum Type {
               ResourceUnavailable,  // e.g. failure to access a file, URL, database, or other resource
               ServiceUnavailable,   // e.g. failure to connect to a site, load a plugin, extension, or other module
               ConfigurationError,   // required data or properties missing
               AssertionFailure,     // an illegal software state was detected
               OperationCanceled,    // operation was canceled intentionally
               GeneralError          // something else went wrong
           };
   
           Type type = GeneralError;
           std::string message = {};
   
           Failure() = default;
           Failure(const Failure& rhs) = default;
           Failure(Failure&& rhs) noexcept = default;
           Failure& operator = (const Failure& rhs) = default;
   
           explicit Failure(const Type t) : type(t) {}
           explicit Failure(std::string_view m) : message(m) {}
           explicit Failure(const Type t, std::string_view m) : type(t), message(m) {}
   
           std::string string() const {
               if (type == ResourceUnavailable)
                   return "Resource unavailable" + (message.empty() ? "" : "... " + message);
               if (type == ServiceUnavailable)
                   return "Service unavailable" + (message.empty() ? "" : "... " + message);
               if (type == ConfigurationError)
                   return "Configuration error" + (message.empty() ? "" : "... " + message);
               if (type == AssertionFailure)
                   return "Assertion failure" + (message.empty() ? "" : "... " + message);
               if (type == OperationCanceled)
                   return "Operation canceled" + (message.empty() ? "" : "... " + message);
               return "General error" + (message.empty() ? "" : "... " + message);
           }
   
           Failure& operator()(std::string_view m) {
               message = m;
               return *this;
           }
       };
   
       const Failure Failure_ServiceUnavailable(Failure::ServiceUnavailable);
       const Failure Failure_ResourceUnavailable(Failure::ResourceUnavailable);
       const Failure Failure_ConfigurationError(Failure::ConfigurationError);
       const Failure Failure_AssertionFailure(Failure::AssertionFailure);
       const Failure Failure_OperationCanceled(Failure::OperationCanceled);
       const Failure Failure_GeneralError(Failure::GeneralError);
   
       template<typename T = std::nullopt_t, typename E = Failure>
       class [[nodiscard]] Result
       {
       public:
           Result(const Result& rhs) = default;
   
           Result(const T& good) {
               _value.template emplace<T>(good);
           }
           Result(T&& good) noexcept {
               _value.template emplace<T>(std::move(good));
           }
           Result(const E& bad) {
               _value.template emplace<E>(bad);
           }
           Result(E&& bad) noexcept {
               _value.template emplace<E>(std::move(bad));
           }
           Result& operator = (const Result& rhs) {
               if (this != &rhs) {
                   if (std::holds_alternative<T>(rhs._value))
                       _value.template emplace<T>(std::get<T>(rhs._value));
                   else if (std::holds_alternative<E>(rhs._value))
                       _value.template emplace<E>(std::get<E>(rhs._value));
               }
               return *this;
           }
   
           Result& operator = (const E& bad) {
               _value.template emplace<E>(bad);
               return *this;
           }
           Result& operator = (const T& good) {
               _value.template emplace<T>(good);
               return *this;
           }
   
           [[nodiscard]] bool ok() const {
               return std::holds_alternative<T>(_value);
           }
           [[nodiscard]] bool failed() const {
               return std::holds_alternative<E>(_value);
           }
           [[nodiscard]] operator bool() const {
               return ok();
           }
           [[nodiscard]] T* operator -> () {
               return &value();
           }
           [[nodiscard]] const T* operator -> () const {
               return &value();
           }
           [[nodiscard]] T& value() {
               return std::get<T>(_value);
           }
           [[nodiscard]] T release() {
               return std::move(std::get<T>(_value));
           }
           [[nodiscard]] const T& value() const {
               return std::get<T>(_value);
           }
           [[nodiscard]] const E& error() const {
               return std::get<E>(_value);
           }
   
       private:
           std::variant<std::monostate, T, E> _value;
       };
   
       constexpr std::nullopt_t ResultVoidOK = std::nullopt;
   
       constexpr std::nullopt_t ResultFail = std::nullopt;
   
       class Status
       {
       public:
           Status() = default;
   
           Status(const Failure& f) : _error(f) {}
   
           Status& operator = (const Failure& f) {
               _error = f;
               return *this;
           }
   
           Status& operator = (const Status& rhs) {
               if (this != &rhs) {
                   _error = rhs._error;
               }
               return *this;
           }
   
           inline const Failure& error() const {
               return _error.value();
           }
           inline bool ok() const {
               return !_error.has_value();
           }
           inline bool failed() const {
               return _error.has_value();
           }
           inline void clear() {
               _error.reset();
           }
   
       private:
           std::optional<Failure> _error;
       };
   }
