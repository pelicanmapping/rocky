
.. _program_listing_file_src_rocky_vsg_terrain_TerrainState.h:

Program Listing for File TerrainState.h
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_rocky_vsg_terrain_TerrainState.h>` (``src/rocky/vsg/terrain/TerrainState.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   
   #include <rocky/vsg/VSGContext.h>
   #include <rocky/Color.h>
   #include <rocky/Image.h>
   
   namespace ROCKY_NAMESPACE
   {
       struct TerrainTileModel;
       class TerrainSettings;
   
       struct TerrainDescriptors
       {
           struct Uniforms
           {
               glm::vec4 backgroundColor = Color("#08AEE0");
               float applyWireOverlay = 0.0f;
               float applyLighting = 0.0f;
               float debugNormals = 0.0f;
           };
   
           vsg::ref_ptr<vsg::Data> data;
           vsg::ref_ptr<vsg::Descriptor> ubo;
       };
   
       struct TerrainTileDescriptors
       {
           struct Uniforms
           {
               glm::fmat4 elevation_matrix;
               glm::fmat4 color_matrix;
               glm::fmat4 model_matrix;
               float min_height = 1.0f;
               float max_height = 0.0f;
               float padding[2];
           };
           vsg::ref_ptr<vsg::DescriptorImage> color;
           vsg::ref_ptr<vsg::DescriptorImage> elevation;
           vsg::ref_ptr<vsg::DescriptorBuffer> uniforms;
           vsg::ref_ptr<vsg::StateCommand> bind;
       };
   
       struct TextureData
       {
           std::string name;
           std::shared_ptr<Image> image;
           glm::dmat4 matrix{ 1 };
       };
   
       struct TerrainTileRenderModel
       {
           glm::fmat4 modelMatrix;
           TextureData color;
           TextureData elevation;
           float minHeight = 0.0f;
           float maxHeight = 0.0f;
   
           TerrainTileDescriptors descriptors;
   
           void applyScaleBias(const glm::dmat4& sb)
           {
               if (color.image)
                   color.matrix *= sb;
               if (elevation.image)
                   elevation.matrix *= sb;
           }
       };
   
       class ROCKY_VSG_INTERNAL TerrainState
       {
       public:
           TerrainState(VSGContext);
   
           bool setupTerrainStateGroup(vsg::StateGroup& stateGroup, VSGContext& context);
   
           TerrainTileRenderModel updateRenderModel(
               const TerrainTileRenderModel& oldRenderModel,
               const TerrainTileModel& newDataModel,
               VSGContext& runtime) const;
   
           void updateSettings(const TerrainSettings&);
   
           Status status;
   
       public:
   
           vsg::ref_ptr<vsg::GraphicsPipelineConfig> pipelineConfig;
   
           vsg::ref_ptr<vsg::ShaderSet> shaderSet;
   
           TerrainTileDescriptors defaultTileDescriptors;
   
       protected:
   
           void createDefaultDescriptors(VSGContext&);
   
           vsg::ref_ptr<vsg::ShaderSet> createShaderSet(VSGContext&) const;
   
           vsg::ref_ptr<vsg::GraphicsPipelineConfig> createPipelineConfig(VSGContext&) const;
   
           struct TextureDef
           {
               // name in the shader
               std::string name;
   
               // binding point (layout binding=X) in the shader
               uint32_t uniform_binding;
   
               // sampler to use
               vsg::ref_ptr<vsg::Sampler> sampler;
   
               // default placeholder texture data
               vsg::ref_ptr<vsg::Data> defaultData;
           };
   
           struct
           {
               TextureDef color;
               TextureDef elevation;
           }
           texturedefs;
   
           // terrain-wide settings, etc.
           TerrainDescriptors _terrainDescriptors;
       };
   }
