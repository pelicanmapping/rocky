
.. _program_listing_file_src_rocky_vsg_PixelScaleTransform.h:

Program Listing for File PixelScaleTransform.h
==============================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_rocky_vsg_PixelScaleTransform.h>` (``src/rocky/vsg/PixelScaleTransform.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   #include <rocky/vsg/Common.h>
   #include <rocky/Math.h>
   
   namespace ROCKY_NAMESPACE
   {
       class ROCKY_EXPORT PixelScaleTransform : public vsg::Inherit<vsg::Transform, PixelScaleTransform>
       {
       public:
           bool unrotate = false;
           bool snap = false;
           float unitSize = 1.0f;
           float renderSize = 1.0f;
   
           void accept(vsg::RecordTraversal& rt) const override
           {
               // Calculate the scale factor that will scale geometry from pixel space to model space
               auto& state = *rt.getState();
               auto& viewport = state._commandBuffer->viewDependentState->viewportData->at(0);
   
               double d = state.lodDistance(vsg::dsphere(0.0, 0.0, 0.0, 0.5)) / viewport[3]; // vp height
               d *= (renderSize / unitSize);
   
               matrix = vsg::scale(d);
   
               if (unrotate)
               {
                   auto& mv = state.modelviewMatrixStack.top();
                   auto rotation = quaternion_from_unscaled_matrix<vsg::dquat>(mv);
                   matrix = matrix * vsg::rotate(vsg::inverse(rotation));
               }
   
               if (snap)
               {
                   auto mvp = state.projectionMatrixStack.top() * state.modelviewMatrixStack.top();
                   auto clip = mvp * matrix;
   
                   clip[3][0] = 0.5 * (clip[3][0] / clip[3][3]) * viewport[2];
                   clip[3][1] = 0.5 * (clip[3][1] / clip[3][3]) * viewport[3];
                   clip[3][0] = 2.0 * (floor(clip[3][0]) / viewport[2]) * clip[3][3];
                   clip[3][1] = 2.0 * (floor(clip[3][1]) / viewport[3]) * clip[3][3];
   
                   matrix = vsg::inverse(mvp) * clip;
               }
   
               rt.apply(*this);
           };
   
           vsg::dmat4 transform(const vsg::dmat4& mv) const override
           {
               return mv * matrix;
           }
   
   
       private:
           mutable vsg::dmat4 matrix;
       };
   
       class ROCKY_EXPORT ScreenSpaceGroup : public vsg::Inherit<vsg::Group, ScreenSpaceGroup>
       {
       public:
           bool snap = true;
           double scale = 1.0;
           VSGContext vsgcontext;
   
           void traverse(vsg::RecordTraversal& rt) const override
           {
               auto& state = *rt.getState();
               auto& viewport = state._commandBuffer->viewDependentState->viewportData->at(0);
   
               auto ortho = vsg::orthographic(0.0, (double)viewport[2]-1.0, 0.0, (double)viewport[3]-1.0, -1.0, 1.0);
   
               auto mvp = state.projectionMatrixStack.top() * state.modelviewMatrixStack.top();
               auto clip = mvp * vsg::dvec4(0,0,0,1);
               auto x = ((clip.x / clip.w) * 0.5 + 0.5) * viewport[2] + viewport[0];
               auto y = ((clip.y / clip.w) * 0.5 + 0.5) * viewport[3] + viewport[1];
               
               // snap position to the nearest pixel to prevent "swimming"
               vsg::dmat4 modelview = vsg::dmat4(1);
               modelview[3][0] = snap ? std::floor(x) : x;
               modelview[3][1] = snap ? std::floor(viewport[3] - y) : viewport[3] - y;
   
               double dpr = vsgcontext ? (double)vsgcontext->devicePixelRatio() : 1.0;
               modelview[0][0] = modelview[1][1] = scale * dpr;
   
               state.projectionMatrixStack.push(ortho);
               state.modelviewMatrixStack.push(modelview);
               state.dirty = true;
               state.pushFrustum();
   
               Inherit::traverse(rt);
   
               state.popFrustum();
               state.modelviewMatrixStack.pop();
               state.projectionMatrixStack.pop();
               state.dirty = true;
           }
       };
   }
