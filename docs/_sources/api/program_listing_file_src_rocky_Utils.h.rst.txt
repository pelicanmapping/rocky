
.. _program_listing_file_src_rocky_Utils.h:

Program Listing for File Utils.h
================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_rocky_Utils.h>` (``src/rocky/Utils.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   
   #include <rocky/Common.h>
   #include <rocky/Threading.h>
   
   #include <algorithm>
   #include <cctype>
   #include <functional>
   #include <memory>
   #include <mutex>
   #include <sstream>
   #include <stdexcept>
   #include <string>
   #include <vector>
   #include <optional>
   
   
   namespace ROCKY_NAMESPACE
   {
       namespace util
       {
           const std::string EMPTY_STRING = {};
   
           extern ROCKY_EXPORT std::optional<std::string> getEnvVar(std::string_view name);
   
           extern ROCKY_EXPORT bool isEnvVarSet(const char* name);
   
           template<typename T, typename V>
           inline int indexOf(const T& container, const V& v)
           {
               return std::distance(container.begin(), std::find(container.begin(), container.end(), v));
           }
   
           template<typename ... Args>
           std::string format(const std::string& format, Args... args) {
               int size_s = std::snprintf( nullptr, 0, format.c_str(), args... ) + 1; // Extra space for '\0'
               if( size_s <= 0 ) { throw std::runtime_error( "Error during formatting." ); }
               auto size = static_cast<size_t>( size_s );
               std::unique_ptr<char[]> buf( new char[ size ] );
               std::snprintf( buf.get(), size, format.c_str(), args ... );
               return std::string( buf.get(), buf.get() + size - 1 ); // We don't want the '\0' inside
           }
   
           extern ROCKY_EXPORT std::string& replaceInPlace(
               std::string& in_out,
               std::string_view pattern,
               std::string_view replacement);
   
           extern ROCKY_EXPORT std::string trim(std::string_view in);
   
           extern ROCKY_EXPORT std::string& trimInPlace(std::string& str);
   
           inline char toLower(char c) {
               return (c < 0x80) ? c | ((c >= 'A' && c <= 'Z') ? 0x20 : 0x00) : std::tolower(c);
           }
   
           inline std::string toLower(std::string_view in) {
               std::string out(in);
               std::transform(out.begin(), out.end(), out.begin(), [](unsigned char c) { return toLower(c); });
               return out;
           }
   
           inline std::string& toLowerInPlace(std::string& in) {
               std::transform(in.begin(), in.end(), in.begin(), [](unsigned char c) { return toLower(c); });
               return in;
           }
   
           extern ROCKY_EXPORT bool startsWith(
               std::string_view ref,
               std::string_view pattern,
               bool caseSensitive = true);
   
           extern ROCKY_EXPORT bool endsWith(
               std::string_view ref,
               std::string_view pattern,
               bool caseSensitive = true);
   
           extern ROCKY_EXPORT bool ciEquals(
               std::string_view lhs,
               std::string_view rhs);
   
           extern ROCKY_EXPORT std::string getExecutableLocation();
   
           template<typename T>
           struct vector_map_equal {
               inline bool operator()(const T& a, const T& b) const {
                   return a == b;
               }
           };
   
           template<typename KEY, typename DATA, typename EQUAL = vector_map_equal<KEY>>
           struct vector_map
           {
               struct ENTRY {
                   KEY first; DATA second;
               };
               using value_type = DATA;
               using container_t = std::vector<ENTRY>;
               using iterator = typename container_t::iterator;
               using const_iterator = typename container_t::const_iterator;
               EQUAL keys_equal;
   
               container_t _container;
   
               inline DATA& operator[](const KEY& key) {
                   for (unsigned i = 0; i < _container.size(); ++i) {
                       if (keys_equal(_container[i].first, key)) {
                           return _container[i].second;
                       }
                   }
                   _container.resize(_container.size() + 1);
                   _container.back().first = key;
                   return _container.back().second;
               }
   
               inline DATA& emplace(const KEY& key, const DATA& data) {
                   auto& entry = operator[](key);
                   entry = data;
                   return entry;
               }
   
               inline DATA& emplace(const KEY& key, DATA&& data) {
                   auto& entry = operator[](key);
                   entry = std::move(data);
                   return entry;
               }
   
               inline const_iterator begin() const { return _container.begin(); }
               inline const_iterator end()   const { return _container.end(); }
               inline iterator begin() { return _container.begin(); }
               inline iterator end() { return _container.end(); }
   
               inline iterator find(const KEY& key) {
                   for (unsigned i = 0; i < _container.size(); ++i) {
                       if (keys_equal(_container[i].first, key)) {
                           return _container.begin() + i;
                       }
                   }
                   return _container.end();
               }
   
               inline const_iterator find(const KEY& key) const {
                   for (unsigned i = 0; i < _container.size(); ++i) {
                       if (keys_equal(_container[i].first, key)) {
                           return _container.begin() + i;
                       }
                   }
                   return _container.end();
               }
   
               inline bool empty() const { return _container.empty(); }
   
               inline void clear() { _container.clear(); }
   
               inline void erase(const KEY& key) {
                   for (unsigned i = 0; i < _container.size(); ++i) {
                       if (keys_equal(_container[i].first, key)) {
                           if (i + 1 < _container.size()) {
                               _container[i] = _container[_container.size() - 1];
                           }
                           _container.resize(_container.size() - 1);
                           break;
                       }
                   }
               }
   
               inline int indexOf(const KEY& key) const {
                   for (std::size_t i = 0; i < _container.size(); ++i) {
                       if (keys_equal(_container[i].first, key)) {
                           return (int)i;
                       }
                   }
                   return -1;
               }
   
               inline std::size_t size() const { return _container.size(); }
   
               template<typename InputIterator>
               void insert(InputIterator a, InputIterator b) {
                   for (InputIterator i = a; i != b; ++i) (*this)[i->first] = i->second;
               }
           };
   
           struct make_string
           {
               operator std::string() const
               {
                   std::string result;
                   result = buf.str();
                   return result;
               }
   
               template<typename T>
               make_string& operator << (const T& val) { buf << val; return (*this); }
   
               make_string& operator << (const make_string& val) { buf << (std::string)val; return (*this); }
   
           protected:
               std::stringstream buf;
           };
   
           template<> inline
           make_string& make_string::operator << <bool>(const bool& val) { buf << (val ? "true" : "false"); return (*this); }
   
           class ROCKY_EXPORT StringTokenizer
           {
           public:
               StringTokenizer() = default;
   
               std::vector<std::string> operator()(std::string_view input, bool* error = nullptr) const;
   
               void tokenize(std::string_view input, std::vector<std::string>& output) const {
                   output = operator()(input, nullptr);
               }
   
               std::vector<std::string> tokenize(std::string_view input) const {
                   return operator()(input, nullptr);
               }
   
               StringTokenizer& keepEmpties(bool value) {
                   _allowEmpties = value;
                   return *this;
               }
   
               StringTokenizer& trimTokens(bool value) {
                   _trimTokens = value;
                   return *this;
               }
   
               StringTokenizer& delim(const std::string& value, bool keepAsToken = false) {
                   _delims.emplace(value, keepAsToken);
                   //_delims[value] = keepAsToken;
                   return *this;
               }
   
               StringTokenizer& quote(char opener_and_closer, bool keepInToken = true) {
                   _quotes.emplace(opener_and_closer, std::make_pair(opener_and_closer, keepInToken));
                   return *this;
               }
   
               StringTokenizer& quotePair(char opener, char closer, bool keepInToken = true) {
                   _quotes.emplace(opener, std::make_pair(closer, keepInToken));
                   return *this;
               }
   
               StringTokenizer& whitespaceDelims() {
                   return delim(" ").delim("\t").delim("\n").delim("\r");
               }
   
               StringTokenizer& standardQuotes() {
                   return quote('\'').quote('"');
               }
   
           private:
               using DelimiterMap = vector_map<std::string, bool>; // string, keep?
               using QuoteMap = vector_map<char, std::pair<char, bool>>; // open, close, keep?
   
               vector_map<std::string, bool> _delims;
               vector_map<char, std::pair<char, bool>> _quotes;
               bool _allowEmpties = true;
               bool _trimTokens = true;
           };
   
           extern ROCKY_EXPORT void setThreadName(const char* name);
   
           template<typename T>
           class ROCKY_EXPORT ring_buffer
           {
           public:
               using value_type = T;
   
               ring_buffer(int size = 8, bool overwrite_when_full_ = false) :
                   _size(size), _buffer(size), overwrite_when_full(overwrite_when_full_){}
   
               bool overwrite_when_full = false;
   
               void resize(std::size_t newSize) {
                   _buffer.clear();
                   _buffer.resize(newSize);
                   _size = newSize;
                   _readIndex = { 0 };
                   _writeIndex = { 0 };
               }
   
               bool push(const T& obj) {
                   bool is_full = full();
                   if (is_full && !overwrite_when_full) return false;
                   _buffer[_writeIndex] = obj;
                   if (!is_full) _writeIndex.exchange((_writeIndex + 1) % _size);
                   notify();
                   return true;
               }
   
               bool pop(T& obj) {
                   if (_readIndex == _writeIndex) return false;
                   obj = std::move(_buffer[_readIndex]);
                   _readIndex.exchange((_readIndex + 1) % _size);
                   return true;
               }
   
               T& peek() {
                   return _buffer[_readIndex];
               }
   
               const T& peek() const {
                   return _buffer[_readIndex];
               }
   
           protected:
               virtual void notify() { }
   
               bool empty() const {
                   return _readIndex == _writeIndex;
               }
   
               bool full() const {
                   return (_writeIndex + 1) % _size == _readIndex;
               }
   
           private:
               std::atomic_int _readIndex = { 0 };
               std::atomic_int _writeIndex = { 0 };
               int _size;
               std::vector<T> _buffer;
           };
   
           template<typename T>
           class ROCKY_EXPORT ring_buffer_with_condition : public ring_buffer<T>
           {
           public:
               ring_buffer_with_condition(int size) : ring_buffer<T>(size) {}
   
               template<typename DURATION_T>
               bool wait(DURATION_T timeout) {
                   std::unique_lock<std::mutex> L(_mutex);
                   return _condition.wait_for(L, timeout, [this]() { return !ring_buffer<T>::empty(); });
               }
   
           protected:
               void notify() override {
                   _condition.notify_one();
               }
   
           private:
               mutable std::mutex _mutex;
               mutable std::condition_variable_any _condition;
           };
   
           class ROCKY_EXPORT BackgroundServices
           {
           public:
               using Function = std::function<void(Cancelable&)>;
               using Task = Future<bool>;
               using Promise = Task;
   
               Promise start(const std::string& name, Function function);
   
               void quit();
   
           protected:
               std::mutex mutex;
               std::vector<Task> tasks;
               jobs::detail::semaphore semaphore;
           };
   
   
   
           class StreamCompressor
           {
           public:
               virtual bool compress(const std::string& src, std::ostream& out) const = 0;
   
               virtual bool decompress(std::istream& in, std::string& out) const = 0;
           };
   
   #ifdef ROCKY_HAS_ZLIB
           class ROCKY_EXPORT ZLibCompressor : public StreamCompressor
           {
           public:
               bool compress(const std::string& src, std::ostream& out) const override;
   
               bool decompress(std::istream& in, std::string& out) const override;
           };
   #endif // ROCKY_HAS_ZLIB
   
       }
   }
