
.. _program_listing_file_src_rocky_Callbacks.h:

Program Listing for File Callbacks.h
====================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_rocky_Callbacks.h>` (``src/rocky/Callbacks.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   
   #include <rocky/Common.h>
   
   #include <atomic>
   #include <mutex>
   #include <functional>
   #include <vector>
   #include <unordered_set>
   
   namespace ROCKY_NAMESPACE
   {
       using CallbackSub = std::shared_ptr<bool>;
   
       struct CallbackSubs : public std::unordered_set<CallbackSub> {
           inline CallbackSubs& operator += (CallbackSub sub) {
               this->emplace(sub); return *this;
           }
       };
   
       template<typename F = void()>
       class Callback
       {
       private:
           using SubRef = std::weak_ptr<bool>;
           using Entry = typename std::pair<SubRef, std::function<F>>;
           mutable std::vector<Entry> entries;
           mutable std::mutex mutex;
           mutable std::atomic_bool firing = { false };
   
       public:
           [[nodiscard]]
           CallbackSub operator()(std::function<F>&& func) const {
               std::lock_guard<std::mutex> lock(mutex);
               auto sub = CallbackSub(new bool(true));
               entries.emplace_back(SubRef(sub), func);
               return sub;
           }
   
           void remove(CallbackSub sub) const {
               std::lock_guard<std::mutex> lock(mutex);
               for (auto iter = entries.begin(); iter != entries.end(); ++iter) {
                   if (iter->first == sub) {
                       entries.erase(iter);
                       break;
                   }
               }
           }
   
           template<typename... Args>
           void fire(Args&&... args) const {
               if (firing.exchange(true) == false) {
                   std::lock_guard<std::mutex> lock(mutex);
                   for (auto& e : entries) {
                       if (auto temp = e.first.lock()) // skip abandoned callbacks
                           e.second(args...);
                   }
                   firing = false;
               }
           }
   
           operator bool() const
           {
               return !entries.empty();
           }
       };
   }
