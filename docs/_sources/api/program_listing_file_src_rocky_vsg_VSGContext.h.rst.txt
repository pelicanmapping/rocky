
.. _program_listing_file_src_rocky_vsg_VSGContext.h:

Program Listing for File VSGContext.h
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_rocky_vsg_VSGContext.h>` (``src/rocky/vsg/VSGContext.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   #include <rocky/vsg/Common.h>
   #include <rocky/vsg/Polyfill.h>
   #include <rocky/vsg/VSGUtils.h>
   #include <rocky/Context.h>
   #include <rocky/Callbacks.h>
   #include <rocky/Rendering.h>
   #include <vsg/all.h>
   #include <deque>
   #include <vector>
   
   namespace ROCKY_NAMESPACE
   {
       class MapNode;
   
       class ROCKY_EXPORT VSGContextImpl : public ContextImpl
       {
       public:
           inline const vsg::ref_ptr<vsg::Viewer>& viewer() const;
   
           vsg::ref_ptr<vsg::SharedObjects> sharedObjects;
   
           vsg::ref_ptr<vsg::Options> readerWriterOptions;
   
           vsg::Paths searchPaths;
   
           std::atomic_int renderRequests = { 0 };
   
           void requestFrame();
   
           bool renderingEnabled = true;
   
           vsg::ref_ptr<vsg::ShaderCompileSettings> shaderCompileSettings;
   
           std::function<void(vsg::ref_ptr<vsg::Object>)> disposer;
   
           std::vector<std::uint32_t> activeViewIDs = { 0 };
   
           Callback<> onUpdate;
   
           using GuiRecorder = std::function<void(RenderingState&, void* guiContext)>;
           std::deque<GuiRecorder> guiRecorders;
   
           VulkanExtensions* ext();
   
           std::function<float()> devicePixelRatio = []() { return 1.0f; };
   
       public:
   
           void onNextUpdate(
               vsg::ref_ptr<vsg::Operation> function,
               std::function<float()> get_priority = {});
   
           void onNextUpdate(std::function<void()> function);
   
           vsg::CompileResult compile(vsg::ref_ptr<vsg::Object> object);
   
           void dispose(vsg::ref_ptr<vsg::Object> object);
   
           void upload(const vsg::BufferInfoList& bufferInfos);
           void upload(const vsg::ImageInfoList& inageInfos);
   
           vsg::ref_ptr<vsg::Device> device();
   
           vsg::ref_ptr<vsg::CommandGraph> getComputeCommandGraph() const;
           vsg::ref_ptr<vsg::CommandGraph> getOrCreateComputeCommandGraph(vsg::ref_ptr<vsg::Device> device, int queueFamily);
   
           bool update();
   
       private:
           vsg::ref_ptr<vsg::Viewer> _viewer;
   
           // for (some) update operations
           vsg::ref_ptr<vsg::Operation> _priorityUpdateQueue;
   
           mutable std::mutex _compileMutex;
           vsg::CompileResult _compileResult;
   
           // deferred deletion container (garbage collector)
           mutable std::mutex _gc_mutex;
           std::deque<std::vector<vsg::ref_ptr<vsg::Object>>> _gc;
   
           vsg::ref_ptr<vsg::CommandGraph> _computeCommandGraph;
   
           vsg::ref_ptr<VulkanExtensions> _vulkanExtensions;
   
       private:
           VSGContextImpl(vsg::ref_ptr<vsg::Viewer> viewer);
   
           VSGContextImpl(vsg::ref_ptr<vsg::Viewer> viewer, int& argc, char** argv);
   
           VSGContextImpl(const VSGContextImpl& rhs) = delete;
           VSGContextImpl(VSGContextImpl&& rhs) noexcept = delete;
   
           void ctor(int& argc, char** argv);
   
           friend class Application;
           friend class VSGContextFactory;
           friend class MapNode;
       };
   
       inline const vsg::ref_ptr<vsg::Viewer>& VSGContextImpl::viewer() const {
           return _viewer;
       }
   
       using VSGContext = std::shared_ptr<VSGContextImpl>;
   
       class VSGContextFactory
       {
       public:
           template<typename... Args>
           static VSGContext create(Args&&... args) {
               return VSGContext(new VSGContextImpl(std::forward<Args>(args)...));
           }
       };
   }
