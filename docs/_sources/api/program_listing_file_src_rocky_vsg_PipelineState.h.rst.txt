
.. _program_listing_file_src_rocky_vsg_PipelineState.h:

Program Listing for File PipelineState.h
========================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_rocky_vsg_PipelineState.h>` (``src/rocky/vsg/PipelineState.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   #include <rocky/vsg/Common.h>
   
   namespace ROCKY_NAMESPACE
   {
       // Shader binding set and binding points for VSG's view-dependent data.
       // See vsg::ViewDependentState
       constexpr int VSG_VIEW_DEPENDENT_DESCRIPTOR_SET_INDEX = 1;
       constexpr int VSG_VIEW_DEPENDENT_LIGHTS_BINDING = 0;
       constexpr int VSG_VIEW_DEPENDENT_VIEWPORTS_BINDING = 1;
       
   
       struct PipelineUtils
       {
           static void addViewDependentData(vsg::ShaderSet* shaderSet, VkShaderStageFlags stageFlags)
           {
               // override it because we're getting weird VK errors -gw
               stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
   
               // VSG view-dependent data. You must include it all even if you only intend to use
               // one of the uniforms.
               shaderSet->customDescriptorSetBindings.push_back(
                   vsg::ViewDependentStateBinding::create(VSG_VIEW_DEPENDENT_DESCRIPTOR_SET_INDEX));
   
               shaderSet->addDescriptorBinding(
                   "vsg_lights", "",
                   VSG_VIEW_DEPENDENT_DESCRIPTOR_SET_INDEX,
                   VSG_VIEW_DEPENDENT_LIGHTS_BINDING,
                   VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1,
                   stageFlags, {});
   
               // VSG viewport state
               shaderSet->addDescriptorBinding(
                   "vsg_viewports", "",
                   VSG_VIEW_DEPENDENT_DESCRIPTOR_SET_INDEX,
                   VSG_VIEW_DEPENDENT_VIEWPORTS_BINDING,
                   VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1,
                   stageFlags, {});
           }
   
           static vsg::ref_ptr<vsg::DescriptorSetLayout> getViewDependentDescriptorSetLayout()
           {
               return vsg::DescriptorSetLayout::create(
                   vsg::DescriptorSetLayoutBindings{
                       {VSG_VIEW_DEPENDENT_LIGHTS_BINDING, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1, VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT},
                       {VSG_VIEW_DEPENDENT_VIEWPORTS_BINDING, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT}
                   }
               );
           }
   
           static void enableViewDependentData(vsg::ref_ptr<vsg::GraphicsPipelineConfigurator> pipelineConfig)
           {
               pipelineConfig->enableDescriptor("vsg_lights");
               pipelineConfig->enableDescriptor("vsg_viewports");
           }
       };
   
   
       class ROCKY_EXPORT DescriptorBufferEx : public vsg::Inherit<vsg::DescriptorBuffer, DescriptorBufferEx>
       {
       public:
           explicit DescriptorBufferEx(const vsg::BufferInfoList& in_bufferInfoList, uint32_t dstBinding, uint32_t dstArrayElement, VkDescriptorType descriptorType, VkBufferUsageFlags in_additionalUsageFlags, bool in_compileAndTransferRequired) :
               Inherit(in_bufferInfoList, dstBinding, dstArrayElement, descriptorType),
               additionalUsageFlags(in_additionalUsageFlags),
               compileAndTransferRequired(in_compileAndTransferRequired)
           {
               //nop
           }
   
           VkBufferUsageFlags additionalUsageFlags = 0;
   
           bool compileAndTransferRequired = true;
   
           void compile(vsg::Context& context) override;
       };
   
   
       class ROCKY_EXPORT StreamingGPUBuffer : public vsg::Inherit<vsg::Command, StreamingGPUBuffer>
       {
       public:
           vsg::ref_ptr<vsg::BufferInfo> ssbo;
   
           vsg::ref_ptr<vsg::DescriptorBuffer> descriptor;
   
           StreamingGPUBuffer(std::uint32_t binding, VkDeviceSize size, VkBufferUsageFlags in_usage, VkSharingMode in_sharingMode = VK_SHARING_MODE_EXCLUSIVE);
   
           template<class T>
           inline T* data() {
               return static_cast<T*>(_data->dataPointer());
           }
   
           void dirty() {
               dirty_region = VkBufferCopy{ 0, 0, _data->dataSize() };
           }
   
           void dirty(VkDeviceSize offset, VkDeviceSize range) {
               dirty_region = VkBufferCopy{ offset, offset, range };
           }
   
       public:
   
           void compile(vsg::Context& context) override;
   
           void record(vsg::CommandBuffer& commandBuffer) const override;
   
       protected:
           vsg::ref_ptr<vsg::Data> _data;
           VkBufferUsageFlags usage_flags;
           VkSharingMode sharing_mode;
           vsg::ref_ptr<vsg::Buffer> staging;
           mutable VkBufferCopy dirty_region = VkBufferCopy{ 0, 0, 0 };
       };
   }
