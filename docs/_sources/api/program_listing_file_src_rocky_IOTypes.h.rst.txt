
.. _program_listing_file_src_rocky_IOTypes.h:

Program Listing for File IOTypes.h
==================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_rocky_IOTypes.h>` (``src/rocky/IOTypes.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   
   #include <rocky/Result.h>
   #include <rocky/Threading.h>
   #include <rocky/Cache.h>
   #include <optional>
   #include <string>
   #include <cstdint>
   #include <chrono>
   
   namespace ROCKY_NAMESPACE
   {
       class IOOptions;
       class Image;
       class Layer;
       class ContextImpl;
       class GeoExtent;
   
       using ReadImageURIService = std::function<
           Result<std::shared_ptr<Image>>(const std::string& location, const IOOptions&)>;
   
       using ReadImageStreamService = std::function<
           Result<std::shared_ptr<Image>>(std::istream& stream, std::string contentType, const IOOptions& io)>;
   
       using WriteImageStreamService = std::function<
           Result<>(std::shared_ptr<Image> image, std::ostream& stream, std::string contentType, const IOOptions& io)>;
   
       using DealpoolService = util::LRUCache<std::string, Failure>;
   
       struct Content {
           std::string type;   // i.e., content-type or mime-type
           std::string data;   // actual data buffer
           std::chrono::system_clock::time_point timestamp;
       };
   
       using ContentCache = rocky::util::LRUCache<std::string, Result<Content>>;
   
       class ROCKY_EXPORT Services
       {
       public:
           Services();
           Services(const Services&) = default;
           Services& operator=(const Services&) = default;
           Services(Services&&) noexcept = delete;
           Services& operator=(Services&&) noexcept = delete;
   
           ReadImageURIService readImageFromURI;
   
           ReadImageStreamService readImageFromStream;
   
           WriteImageStreamService writeImageToStream;
   
           detail::Gate<std::string> uriGate;
   
           std::shared_ptr<ContentCache> contentCache;
   
           std::shared_ptr<util::ResidentCache<std::string, Image, GeoExtent>> residentImageCache;
   
           std::shared_ptr<DealpoolService> deadpool;
       };
   
       class ROCKY_EXPORT IOOptions : public Cancelable
       {
       public:
           IOOptions();
           inline IOOptions(const IOOptions& rhs) = default;
           inline IOOptions(IOOptions&& rhs) { *this = rhs; }
           inline IOOptions& operator=(IOOptions&&) noexcept;
   
           inline IOOptions from(const std::string& referrer);
   
           inline IOOptions with(Cancelable& c) const;
   
           inline bool canceled() const override;
   
           unsigned maxNetworkAttempts = 4u;
   
           std::chrono::seconds networkConnectionTimeout = std::chrono::seconds(5);
   
           std::optional<std::string> referrer;
   
           inline Services& services() const;
   
       public:
           IOOptions& operator = (const IOOptions& rhs) = default;
   
       private:
           Cancelable* _cancelable = nullptr;
           mutable std::shared_ptr<Services> _services;
       };
   
   
       // inlines
       IOOptions& IOOptions::operator = (IOOptions&& rhs) noexcept
       {
           if (this != &rhs)
           {
               Cancelable::operator=(rhs);
               maxNetworkAttempts = rhs.maxNetworkAttempts;
               referrer = std::move(rhs.referrer);
               _services = rhs._services;
               _cancelable = rhs._cancelable;
               rhs._cancelable = nullptr;
           }
           return *this;
       }
   
       inline IOOptions IOOptions::from(const std::string& referrer) {
           IOOptions copy(*this);
           copy.referrer = referrer;
           return copy;
       }
   
       inline IOOptions IOOptions::with(Cancelable& c) const {
           IOOptions copy(*this);
           copy._cancelable = &c;
           return copy;
       }
   
       inline bool IOOptions::canceled() const {
           return _cancelable ? _cancelable->canceled() : false;
       }
   
       inline Services& IOOptions::services() const {
           return *_services;
       }
   }
