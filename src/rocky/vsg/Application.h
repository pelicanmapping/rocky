/**
 * rocky c++
 * Copyright 2023 Pelican Mapping
 * MIT License
 */
#pragma once
#include <rocky/vsg/VSGContext.h>
#include <rocky/vsg/MapNode.h>
#include <rocky/vsg/SkyNode.h>
#include <rocky/ecs/Registry.h>
#include <rocky/vsg/ecs/ECSNode.h>
#include <rocky/vsg/DisplayManager.h>
#include <rocky/Callbacks.h>

#include <chrono>
#include <deque>
#include <functional>
#include <cstdint>

namespace ROCKY_NAMESPACE
{
    class RenderImGuiContext;

    class ROCKY_EXPORT Application
    {
    public:
        //! Construct a new application object
        Application();

        //! Construct a new application object
        //! @param argc Number of command line arguments, including the exe name
        //! @param argv Command line arguments
        Application(int& argc, char** argv);

        //! Construct a new application object
        //! @param viewer The viewer to use
        Application(vsg::ref_ptr<vsg::Viewer> viewer);

        //! Construct a new application object
        //! @param viewer The viewer to use
        //! @param argc Number of command line arguments, including the exe name
        //! @param argv Command line arguments
        Application(vsg::ref_ptr<vsg::Viewer> viewer, int& argc, char** argv);

        //! Run until exit.
        //! @return exit code, 0 = no error
        int run();

        //! Process and render one frame. If you call run(), this will
        //! happen automatically in a continuous loop.
        //! @return True upon success; false to quit the application.
        bool frame();

        //! Queues a function to run during the next update cycle,
        //! during which it's safe to modify the scene graph and use the
        //! display manager.
        void onNextUpdate(std::function<void()> func);

        //! About the application. Lists all the dependencies and their versions.
        std::string about() const;

        //! True if the debug validation layer is active, which will affect performance
        bool debugLayerOn() const {
            return _debuglayer;
        }

        //! Creates the default window. This is called automatically by run() if you
        //! don't call it yourself. You may need to call this yourself if you plan to
        //! access windows, views, or manipulators before starting the frame loop.
        void realize();

        //! Shortcut to the instance's IOOptions
        inline IOOptions& io();

        //! Whether this application is still active
        inline bool active() const;

        //! Installs a RenderImGuiContext that will render ImGui elements
        void install(vsg::ref_ptr<RenderImGuiContext>);

        //! Frame number
        std::uint64_t frameCount() const;

        //! Did this object initialize successfully?
        inline bool ok() const;

    public: // public properties

        //! ECS registry associated with this Application
        Registry registry = Registry::create();

        //! VSG context object
        rocky::VSGContext vsgcontext;

        //! Keeps track of windows and views
        DisplayManager display;

        //! Runs ongoing background tasks
        util::BackgroundServices background;

        //! Scene graph elements
        vsg::ref_ptr<vsg::Viewer> viewer;
        vsg::ref_ptr<vsg::Group> root;
        vsg::ref_ptr<vsg::Group> mainScene;
        vsg::ref_ptr<rocky::MapNode> mapNode;
        vsg::ref_ptr<rocky::SkyNode> skyNode;
        vsg::ref_ptr<rocky::detail::ECSNode> ecsNode;

        //! Continuous render mode.
        //! When true, the viewer will render frames continuously as fast as the CPU
        //! (or the VSYNC) will allow. When false, the viewer will only paint a frame
        //! when requested to do so by setting renderRequests to a non-zero value or
        //! by calling vsgcontetx->requestFrame().
        bool renderContinuously = false;

        //! When true, the application will automatically create a main window
        //! on the first frame if the user does not add one via the display manager.
        bool autoCreateWindow = true;

        //! Access to any status message generated by parsing the command line arguments
        //! passed into the constructor.
        Status commandLineStatus;

        //! When VSGContext::renderContinuously is false, these are functions that will
        //! be invoked when NOT rendering a frame.
        using IdleFunction = std::shared_ptr<std::function<void()>>;
        std::deque<IdleFunction> idleFunctions;

        //! Runtime timing statistics
        struct Stats
        {
            std::chrono::microseconds frame;
            std::chrono::microseconds events;
            std::chrono::microseconds update;
            std::chrono::microseconds record;
            std::chrono::microseconds present;
            double memory;

        };
        Stats stats;

    public:
        //! Copy construction is disabled.
        Application(const Application&) = delete;

        //! Move construction is disabled.
        Application(Application&&) = delete;

        //! Destructor
        ~Application();

    private:
        bool _apilayer = false;
        bool _debuglayer = false;
        bool _vsync = true;
        bool _multithreaded = true;
        bool _viewerRealized = false;
        int _framesSinceLastRender = 0; // for non-continuous rendering
        bool _lastFrameOK = true;
        int _framesUntilStopRender = 2; // for non-continuous rendering
        CallbackSubs _subs;

        void ctor(int& argc, char** argv);

        void setupViewer(vsg::ref_ptr<vsg::Viewer> viewer);
        void install(vsg::ref_ptr<RenderImGuiContext>, bool installIdleFunction);

        friend class DisplayManager;
    };


    inline IOOptions& Application::io() {
        return vsgcontext->io;
    }

    inline bool Application::active() const {
        return _lastFrameOK;
    }

    inline bool Application::ok() const {
        return vsgcontext && vsgcontext->status.ok();
    }
}

